<?xml version="1.0" ?>
<!-- 

http://code.msdn.microsoft.com/HVRemote
See this site for license terms, a copy of the documentation and change history.


By:                 John Howard
Blog:               http://blogs.technet.com/jhoward
Originally Created: October/November 2008 while on vacation!
Last Updated:       7th August 2009 - Version 0.7
About:              Script for configuring Hyper-V Remote Management

-->
<package>
 <job>
 <?job error="True" debug="True" ?>

  <!-- Global object for scripting against WMI. Added as a reference to get constants -->
  <object id="oSWbemLocator" progid="WbemScripting.SWbemLocator" reference="true"/>

  <!-- Reference to Active Directory Scripting Interface (ADSI) for constants -->
  <!-- Commented out. Not sure why can't be instantiated on one box -->
  <!-- <reference object="ADs"/> -->

  <!-- Reference to AZMan (azroles.dll) -->
  <reference object="AzRoles.AzAuthorizationStore"/>

  <!-- Start of the HVRemote script. Note is in VBScript so can run on server core installations
       of Windows Server 2008, Windows Server 2008 R2 plus Hyper-V Server 2008 or 2008 R2 
       where there is no PowerShell environment -->
 
  <script language="VBscript">

   <![CDATA[

    Option Explicit                  ' Must declare our variables
    On error resume next             ' We do the error handling ourselves

    Const VERSION = "0.7"   ' Refresh release 1 7:19PM 8/7
    Const RELEASE_DATE = "7th August 2009"
    Const BLOG_URL_TO_THIS_TOOL = "http://tinyurl.com/kvov7c"
    Const CODE_MSDN_URL = "http://code.msdn.microsoft.com/HVRemote"

    ' ADs Constants ' Alternate to <reference object="ADs"/> which didnt' work on one box
    Const ADS_ACETYPE_ACCESS_ALLOWED = 0
    Const ADS_ACETYPE_ACCESS_DENIED  = 1

    Const ADS_ACEFLAG_FAILED_ACCESS = 128
    Const ADS_ACEFLAG_INHERIT_ACE = 2
    Const ADS_ACEFLAG_INHERIT_ONLY_ACE = 8
    Const ADS_ACEFLAG_INHERITED_ACE = 16
    Const ADS_ACEFLAG_NO_PROPAGATE_INHERIT_ACE = 4
    Const ADS_ACEFLAG_SUCCESSFUL_ACCESS = 64
    Const ADS_ACEFLAG_VALID_INHERIT_FLAGS = 31

    ' Function return code
    Const NO_ERROR = 0
    Const ERROR_ALREADY_PRESENT = -1  ' Custom RC if ACE already present in DACL when adding it
    Const ERROR_NOT_PRESENT = -2      ' Custom RC if ACE is not present in DACL when removing it
    Const SE_DACL_PRESENT = 4

    ' Namespaces we are interested in working with for Hyper-V Remote Management. Note is bitmask
    Const NAMESPACE_CIMv2          = &H1
    Const NAMESPACE_VIRTUALIZATION = &H2

    ' Return error when group or user not found
    Const ERROR_OBJECT_NOT_FOUND = &H80041002

    ' For machine DCOM callback access restriction
    Const HKEY_LOCAL_MACHINE = &H80000002
    Const MACHINE_RESTRICTION_PATH = "Software\Microsoft\Ole"
    Const MACHINE_ACCESS_RESTRICTION_KEY  = "MachineAccessRestriction"
    Const MACHINE_LAUNCH_RESTRICTION_KEY  = "MachineLaunchRestriction"
    Const ACCESS_PERMISSION_LOCAL_ACCESS  = 2 ' Actually 2. No idea what LSBit is. Always set though
    Const ACCESS_PERMISSION_REMOTE_ACCESS = 4 ' Actually 4. No idea what LSBit is. Always set though
    Const ACCESS_PERMISSION_LOCAL_ACTIVATION = 8
    Const ACCESS_PERMISSION_REMOTE_ACTIVATION = 16
    Const ACCESS_PERMISSION_OTHER_FLAG    = 1 ' No idea but always needs to be set

    ' WMI Namespace Access Rights Constants
    ' http://msdn.microsoft.com/en-us/library/aa392710(VS.85).aspx
    Const WBEM_ENABLE            = &h1 
    Const WBEM_METHOD_EXECUTE    = &h2 
    Const WBEM_FULL_WRITE_REP    = &h4 
    Const WBEM_PARTIAL_WRITE_REP = &h8 
    Const WBEM_WRITE_PROVIDER    = &h10 
    Const WBEM_REMOTE_ACCESS     = &h20 
    Const READ_CONTROL           = &h20000 
    Const WRITE_DAC              = &h40000 


    ' Well known SIDs
    ' http://support.microsoft.com/kb/243330. Not hard coded group name as it is localised. SID is universal though.
    Const SID_EVERYONE                    = "S-1-1-0"
    Const SID_ANONYMOUS                   = "S-1-5-7"
    Const SID_BUILTIN_ADMINISTRATORS      = "S-1-5-32-544"
    Const SID_PERFORMANCE_LOG_USERS       = "S-1-5-32-559"
    Const SID_DISTRIBUTED_COM_USERS       = "S-1-5-32-562"

    ' Mode we are operating in: Server or Client configuration
    Const HVREMOTE_MODE_UNKNOWN = 0
    Const HVREMOTE_MODE_CLIENT = 1
    Const HVREMOTE_MODE_SERVER = 2
    
    ' Debug Mode    
    Const DBG_NONE      = 0
    Const DBG_STD       = 1
    Const DBG_EXTRA     = 2

    ' Are we configuring Anonymous DCOM (client)
    Const HVREMOTE_CLIENTOP_ANONDCOM_NONE   = 0
    Const HVREMOTE_CLIENTOP_ANONDCOM_GRANT  = 1
    Const HVREMOTE_CLIENTOP_ANONDCOM_REVOKE = 2

    ' Are we adding or removing a user (Server)
    Const HVREMOTE_SERVEROP_ADDREMOVEUSER_NONE   = 0
    Const HVREMOTE_SERVEROP_ADDREMOVEUSER_ADD    = 1
    Const HVREMOTE_SERVEROP_ADDREMOVEUSER_REMOVE = 2

    ' Are we updating AZMan (Server)
    Const HVREMOTE_SERVEROP_AZMANUPDATE_OFF = 0
    Const HVREMOTE_SERVEROP_AZMANUPDATE_ON  = 1

    ' Are we configuring DCOM Permissions (Server)
    Const HVREMOTE_SERVEROP_DCOMPERMISSIONS_OFF = 0
    Const HVREMOTE_SERVEROP_DCOMPERMISSIONS_ON  = 1

    ' Equivalent to netsh advfirewall firewall set rule group="Windows Management Instrumentation (WMI)" new enable=yes
    ' Note. This is not strictly necessary
    Const HVREMOTE_SERVEROP_FIREWALL_WMIMGMT_NONE = 0
    Const HVREMOTE_SERVEROP_FIREWALL_WMIMGMT_ALLOW = 1
    Const HVREMOTE_SERVEROP_FIREWALL_WMIMGMT_DENY = 2
    Const HVREMOTE_SERVEROP_FIREWALL_WMIMGMT_RESOURCE = "@FirewallAPI.dll,-34251"

    ' Equivalent to netsh advfirewall firewall set rule group="Hyper-V" new enable=yes
    Const HVREMOTE_SERVEROP_FIREWALL_HYPERV_NONE = 0
    Const HVREMOTE_SERVEROP_FIREWALL_HYPERV_ALLOW = 1
    Const HVREMOTE_SERVEROP_FIREWALL_HYPERV_DENY = 2
    Const HVREMOTE_SERVEROP_FIREWALL_HYPERV_RESOURCE_V1   = "@%systemroot%\system32\vmms.exe,-99010"  ' 2008
    Const HVREMOTE_SERVEROP_FIREWALL_HYPERV_RESOURCE_Win7 = "@%systemroot%\system32\vmms.exe,-210"    ' 2008 R2

    ' Equivalent to netsh advfirewall firewall set rule group="Hyper-V Management Clients" new enable=yes
    Const HVREMOTE_CLIENTOP_FIREWALL_HYPERVMGMTCLIENT_NONE = 0
    Const HVREMOTE_CLIENTOP_FIREWALL_HYPERVMGMTCLIENT_ALLOW = 1
    Const HVREMOTE_CLIENTOP_FIREWALL_HYPERVMGMTCLIENT_DENY = 2
    Const HVREMOTE_CLIENTOP_FIREWALL_HYPERVMGMTCLIENT_RESOURCE = "@%ProgramFiles%\Hyper-V\SnapInAbout.dll,-211"


    ' Client firewall exception for MMC.exe
    Const HVREMOTE_CLIENTOP_FIREWALL_MMCEXCEPTION_NONE = 0
    Const HVREMOTE_CLIENTOP_FIREWALL_MMCEXCEPTION_ALLOW = 1
    Const HVREMOTE_CLIENTOP_FIREWALL_MMCEXCEPTION_DENY = 2

    ' Client tracing (New 0.7)
    Const HVREMOTE_CLIENTOP_TRACING_NONE = 0
    Const HVREMOTE_CLIENTOP_TRACING_ON = 1
    Const HVREMOTE_CLIENTOP_TRACING_OFF = 2


    ' Firewall Profile Type
    Const NET_FW_PROFILE2_DOMAIN = 1
    Const NET_FW_PROFILE2_PRIVATE = 2
    Const NET_FW_PROFILE2_PUBLIC = 4

    ' Firewall Protocol
    Const NET_FW_IP_PROTOCOL_TCP = 6
    Const NET_FW_IP_PROTOCOL_UDP = 17
    Const NET_FW_IP_PROTOCOL_ICMPv4 = 1
    Const NET_FW_IP_PROTOCOL_ICMPv6 = 58

    ' Firewall Direction
    Const NET_FW_RULE_DIR_IN = 1
    Const NET_FW_RULE_DIR_OUT = 2

    ' Firewall Action
    Const NET_FW_ACTION_BLOCK = 0
    Const NET_FW_ACTION_ALLOW = 1

    ' Authorisation store
    Const AUTH_STORE_PATH = "SOFTWARE\Microsoft\Windows NT\CurrentVersion\Virtualization"
    Const AUTH_STORE_KEY  = "StoreLocation"
    Const AUTH_STORE_SERVICE = "ServiceApplication"

    ' To determine elevation
    Const ELEVATION_UNKNOWN = 0
    Const ELEVATION_NO = 1
    Const ELEVATION_YES = 2


    ' Global declarations
    Dim glClientServerMode                       ' Operating in client or server mode
    Dim gszServerOpAddOrRemoveUserName           ' Server: /add and /remove: Username to update
    Dim gszServerOpAddOrRemoveDomainName         ' Server: /add and /remove: Domain of user to update
    Dim glServerOpAddRemoveUser                  ' Server: Are we adding or removing a user?
    Dim glServerOpAZManUpdate                    ' Server: Are we updating AZMan?
    Dim glServerOpDCOMPermissions                ' Server: Are we updating DCOM permissions?
    Dim glServerOpNameSpacesToUse                ' Server: Which namespaces are we using
    Dim glClientOpAnonDCOMMode                   ' Client: Remote access to DCOM for anonymous logon
    Dim glClientOpTracing                        ' Client: Turning tracing on or off
    Dim glDebugLevel
    Dim gbShowMode                               ' Are we in "Show" mode displaying information
    Dim gbTestConnectivity                       ' Are we in "Show" mode and also testing connectivity to gszRemoteComputerName?
    Dim glServerOpFirewallWMIMgmt                ' Are we changing rule group Windows Management Instrumentation (WMI)
    Dim glServerOpFirewallHyperV                 ' Are we changing rule group Hyper-V
    Dim glClientOpFirewallHyperVMgmtClient       ' Are we changing rule group Hyper-V Management Clients
    Dim glClientOpFirewallMMCException           ' Are we changing the MMC firewall exception (client)
    Dim gbRunningOnWin7                          ' Are we running on Windows 7 (Windows Server 2008 R2) or later?
    Dim glServicePack                            ' Service pack number
    Dim gszAuthStoreServiceApplication           ' Service application in the authorization store
    Dim gszAuthStore                             ' Authorization store file
    Dim gbComputerIsWorkgroup                    ' If we are in a workgroup
    Dim gszLocalComputerName                     ' Name of the local computer
    Dim gszLocalComputerDomainName               ' Domain name of local computer (blank if in workgroup)
    Dim gbIsRoleInstalled                        ' Is the Hyper-V Role installed on this machine?
    Dim gbIsSCVMM                                ' Is the VMM Agent installed on this machine?
    Dim gszRoleAssign                            ' Which role assignment we're using in the AZMan store
    Dim gbVersionCheck                           ' Are we checking if there is a later version?
    Dim glElevated                               ' Is the script running elevated (unknown/no/yes)
    Dim gbIsFirewallRunning                      ' Is the windows firewall service running?
    Dim glWarns                                  ' Number of warnings
    Dim gszWarns                                 ' Summary of the warnings
    Dim gszRemoteComputerName                    ' When testing connectivity
    Dim gbAnonDCOMAllowed                        ' Is anonymous DCOM allowed
    Dim glTestsPassed                            ' Number of tests passed


    ' Latest Version information (if can obtain)
    Dim gszLV_Version                            ' Latest version number  major.minor
    Dim gszLV_Date                               ' Latest version release date
    Dim gszLV_URL                                ' Download URL for latest version
    Dim gszLV_BlogURL                            ' More information


    ' Initialise our globals
    glDebugLevel                       = DBG_NONE
    gbShowMode                         = False
    gbTestConnectivity                 = False
    gbVersionCheck                     = True
    glClientServerMode                 = HVREMOTE_MODE_UNKNOWN    
    glClientOpAnonDCOMMode             = HVREMOTE_CLIENTOP_ANONDCOM_NONE
    gszServerOpAddOrRemoveUserName     = ""
    gszServerOpAddOrRemoveDomainName   = ""
    glServerOpAddRemoveUser            = HVREMOTE_SERVEROP_ADDREMOVEUSER_NONE
    glServerOpAZManUpdate              = HVREMOTE_SERVEROP_AZMANUPDATE_ON
    glServerOpDCOMPermissions          = HVREMOTE_SERVEROP_DCOMPERMISSIONS_ON
    glServerOpNameSpacesToUse          = NAMESPACE_CIMV2 Or NAMESPACE_VIRTUALIZATION
    glServerOpFirewallWMIMgmt          = HVREMOTE_SERVEROP_FIREWALL_WMIMGMT_NONE
    glServerOpFirewallHyperV           = HVREMOTE_SERVEROP_FIREWALL_HYPERV_NONE
    glClientOpFirewallHyperVMgmtClient = HVREMOTE_CLIENTOP_FIREWALL_HYPERVMGMTCLIENT_NONE
    glClientOpFirewallMMCException     = HVREMOTE_CLIENTOP_FIREWALL_MMCEXCEPTION_NONE
    glClientOpTracing                  = HVREMOTE_CLIENTOP_TRACING_NONE
    gbRunningOnWin7                    = False
    glServicePack                      = -1
    gszAuthStoreServiceApplication     = ""
    gbComputerIsWorkgroup              = False  ' Assume domain
    gszLocalComputerName               = ""
    gszLocalComputerDomainName         = ""
    gbIsRoleInstalled                  = False  ' Assume not unless we know otherwise
    gbIsSCVMM                          = False
    gszRoleAssign                      = "Administrator"  
    gszLV_Version                      = ""
    gszLV_Date                         = ""
    gszLV_URL                          = "http://code.msdn.microsoft.com/HVRemote"
    gszLV_BlogURL                      = "http://tinyurl.com/kvov7c"  ' Actual URL just too long!
    'gszLV_BlogURL                      = "http://blogs.technet.com/jhoward/archive/2009/08/07/hvremote-refresh.aspx"
    'gszLV_BlogURL                      = "http://blogs.technet.com/jhoward/archive/2008/11/14/configure-hyper-v-remote-management-in-seconds.aspx"
    glElevated                         = ELEVATION_UNKNOWN
    gbIsFirewallRunning                = False
    glWarns                            = 0
    gszWarns                           = ""
    gszRemoteComputerName              = ""
    gbAnonDCOMAllowed                  = False
    glTestsPassed                      = 0
    
    ' Local Declarations
    Dim oWbemServicesCIMv2, oWbemServicesVirtualization       ' Connections to WMI namespaces
    Dim oWin32SDCIMv2, oWin32SDVirtualization                 ' Security Descriptor (Win32_SecurityDescriptor) for namespaces
    Dim lReturn                                               ' Function Return Value
    Dim oTrustee                                              ' Win32_Trustee object being added/removed from DACL
    Dim szDCOMUsersGroupName                                  ' Localized
    Dim bAnonHasAccess                                        ' Does Anonymous Logon have remote access?
    Dim oMachineAccessSD                                      ' Security descriptor for DCOM Remote access (client)
    Dim oMachineLaunchSD                                      ' Security descriptor for DCOM Remote access (server)
    Dim oAuthStore                                            ' AZMan Authorization store
    Dim bIsTargetInDomain                                     ' If we can determine whether remote target is domain joined
    Dim szDomainOfTarget                                      ' And this holds the domain
    Dim szBuildOfTarget                                       ' This holds the build of the target eg 6.1.7600 for R2 RTM
    Dim arrBuildOfTarget                                      ' This holds the build of the target in array elements ie (6)(1)(7600) for R2 RTM
    Dim bBothComputersAreInSameDomain                         ' Client side - if determined that server is in the same domain


    lReturn                         = NO_ERROR
    set oWbemServicesCIMv2          = Nothing
    set oWbemServicesVirtualization = Nothing
    set oWin32SDCIMv2               = Nothing
    set oWin32SDVirtualization      = Nothing
    set oTrustee                    = Nothing
    szDComUsersGroupName            = ""
    bAnonHasAccess                  = False
    set oMachineAccessSD            = Nothing
    set oMachineLaunchSD            = Nothing
    set oAuthStore                  = Nothing
    bIsTargetInDomain               = False
    szDomainOfTarget                = ""
    szBuildOfTarget                 = ""
    bBothComputersAreInSameDomain   = False


    ' Check this is being launched by cscript
    if instr(lcase(wscript.fullname), "wscript") Then
        MsgBox "Use " & chr(34) & "cscript hvremote.wsf" & chr(34) & " to run this script." & vbcrlf & vbcrlf & _
               "You can optionally set the default engine to cscript using " & vbcrlf & _
                chr(34) & "cscript //h:cscript" & chr(34) & ". (You then only need to enter " & vbcrlf & _
               chr(34) & "HVRemote /mode:client|server Operation [options]" & chr(34) & "." & vbcrlf & vbcrlf & _
               "This script must be run from an elevated command prompt", vbCritical, "HVRemote: Incorrect scripting engine"
        wscript.quit
    end if

    Title ' Display a title about us

    ' We need a CIMv2 namespace connection for just about everything. Connect regardless as just about the first thing we do.
    if (NO_ERROR = lReturn) Then
        Dbg DBG_EXTRA, "Need to connect to cimv2 namespace"
        lReturn = ConnectNameSpace("root\cimv2","", oWbemServicesCIMv2, False)
        if (lReturn) or (oWbemServicesCIMv2 is Nothing) Then
            Error "Giving up as could not connect to root\cimv2 namespace"
            lReturn = -1  
            wscript.quit
        end if
    end if


    ' Are we in a workgroup?
    gbComputerIsWorkGroup = ComputerIsWorkgroup()

    ' Is the Hyper-V Role installed? (So that we can default to assuming server mode)
    gbIsRoleInstalled = IsRoleInstalled(oWbemServicesCIMv2)


    ' Is the SCVMM Agent installed?
    gbIsSCVMM = IsSCVMM(oWbemServicesCIMv2)

    CheckElevation                         ' Works out if we are elevated in glElevated

    ParseCommandLine                       ' Work out what we're being asked to do

    ' If server, make sure it has the role installed
    if (NO_ERROR = lReturn) and _
       (glClientServerMode = HVREMOTE_MODE_SERVER ) and _
       (not gbIsRoleInstalled) Then
        Error "Giving up as this does not appear to be a server with Hyper-V running"
        lReturn = -1
    end if

    ' If server, need to be elevated
    if (NO_ERROR = lReturn) and (glClientServerMode = HVREMOTE_MODE_SERVER) and (glElevated = ELEVATION_NO) Then
        wscript.echo ""
        Error ""
        Error "Must run from an elevated command prompt for all server operations"
        Error ""
        lReturn = -1
    end if

    ' If client and not in /show or /trace then need to be elevated (Change 0.7 add trace)
    if (NO_ERROR = lReturn) and _
       (glClientServerMode = HVREMOTE_MODE_CLIENT) and _
       (glElevated = ELEVATION_NO) and _
       (not gbShowMode) and _
       (glClientOpTracing = HVREMOTE_CLIENTOP_TRACING_NONE) Then
        wscript.echo ""
        Error ""
        Error "All client operations which change the configuration must be run"
        Error "from an elevated command prompt."
        Error ""
        lReturn = -1
    end if

    ' If server, make sure it has the role installed
    if (NO_ERROR = lReturn) and _
       (glClientServerMode = HVREMOTE_MODE_SERVER ) and _
       (gbIsSCVMM) Then
        wscript.echo " "
        Error " "
        Error "Quitting - This server appears to be managed by System Center"
        Error "           Virtual Machine Manager"
        Error " "
        lReturn = -1
    end if

    if (NO_ERROR = lReturn) and (not(oWbemServicesCIMv2 is nothing)) Then
        gbRunningOnWin7 = RunningOnWin7(oWbemServicesCIMv2)
        if gbRunningOnWin7 Then wscript.echo "INFO: Detected Windows 7/Windows Server 2008 R2 OS"
    end if

    ' Is the Windows Firewall running? 0.7 Moved this later. Must be after detected Windows 7
    gbIsFirewallRunning = IsFirewallRunning(oWbemServicesCIMv2)

    ' If v1 (2008 SP1), check QFE is present
    if (NO_ERROR = lReturn) and _
       (glCLientServerMode = HVREMOTE_MODE_SERVER) and _
       (gbRunningOnWin7 = False) and _
       (glServicePack   = 1) Then
        if IsQFEInstalled(oWbemServicesCIMv2, "950050") then
            wscript.echo "INFO: This machine has the Hyper-V (v1) QFE installed (KB950050)"
        else
            Error "Giving up as this server is running Hyper-V pre-release code."
            Error "Install KB950050 from http://support.microsoft.com/kb/950050"
            wscript.quit
        end if
    end if

    ' Do client checks (Both Vista and Win7 - change in v0.7)
    if (NO_ERROR = lReturn) and _
       (glClientServerMode = HVREMOTE_MODE_CLIENT) Then
        lReturn = DoClientChecks(oWbemServicesCIMv2)
    end if
    
    ' Client side. Check tracing (New 0.7)
    if (NO_ERROR = lReturn) And _
       (glClientServerMode = HVREMOTE_MODE_CLIENT) And _
       (gbShowMode) Then
        Call CheckTracing()
    end if


    ' Connect to root\virtualization namespace
    if (NO_ERROR = lReturn) And _
       (0<>(glServerOpNameSpacesToUse And NAMESPACE_VIRTUALIZATION)) And _
       (glClientServerMode = HVREMOTE_MODE_SERVER ) Then
        Dbg DBG_EXTRA, "Need to connect to virtualization namespace"
        lReturn = ConnectNameSpace("root\virtualization", "", oWbemServicesVirtualization, False)
        if (lReturn) or (oWbemServicesVirtualization is Nothing) Then
            Error "Giving up as could not connect to root\virtualization namespace"
            Error "You could try /debug or limiting the namespaces using the /ns option "
            Error "but remote management won't work unless this namespace security is set"
            lReturn = -1  
        end if
    end if

    ' Get the current security descriptor for the cimv2 namespace
    if (NO_ERROR = lReturn) And _
       (0<>(glServerOpNameSpacesToUse And NAMESPACE_CIMv2)) And _
       (glClientServerMode = HVREMOTE_MODE_SERVER ) Then
        Dbg DBG_EXTRA, "Need to get the security desciptor for the CIMv2 namespace"
        lReturn = GetWin32SD (oWbemServicesCIMv2, oWin32SDCIMv2)
        if (lReturn) or (oWin32SDCIMv2 is nothing) Then
            lReturn = -1
            Error "Giving up as not able to get the security descriptor for the cimv2 namespace"
            Error "Are you running as an admin from an *ELEVATED* prompt???"
        end if     
    end if 

    ' Get the current security descriptor for the virtualization namespace
    if (NO_ERROR = lReturn) And _
       (0<>(glServerOpNameSpacesToUse And NAMESPACE_VIRTUALIZATION)) And _
       (glClientServerMode = HVREMOTE_MODE_SERVER ) Then
        Dbg DBG_EXTRA, "Need to get the security desciptor for the virtualization namespace"
        lReturn = GetWin32SD (oWbemServicesVirtualization, oWin32SDVirtualization)
        if (lReturn) or (oWin32SDVirtualization is nothing) Then
            lReturn = -1
            Error "Giving up as not able to get the security descriptor for the virtualization namespace"
            Error "Are you running as an admin from an *ELEVATED* prompt???"
        end if     
    end if 

    ' Display the Security Descriptor for CIMv2 Namespace
    if (NO_ERROR = lReturn) and _
       (gbShowMode) And _
       (0<>(glServerOpNameSpacesToUse And NAMESPACE_CIMv2)) And _
       (glClientServerMode = HVREMOTE_MODE_SERVER ) Then
        Dbg DBG_EXTRA, "Showing the cimv2 namespace SD"
        DisplayWin32SD "root\cimv2", 1, oWin32SDCimv2
    end if

    ' Display the Security Descriptor for Virtualization Namespace
    if (NO_ERROR = lReturn) and _
       (gbShowMode) And _
       (0<>(glServerOpNameSpacesToUse And NAMESPACE_VIRTUALIZATION)) And _
       (glClientServerMode = HVREMOTE_MODE_SERVER ) Then
        Dbg DBG_EXTRA, "Showing the virtualization namespace SD"
        DisplayWin32SD "root\virtualization", 1, oWin32SDVirtualization
        if (lReturn) Then Error "Giving up as could not display the virtualization namespace security descriptor"
    end if


    ' Open the authorization policy store
    if (NO_ERROR = lReturn) and _
       (glServerOpAZManUpdate = HVREMOTE_SERVEROP_AZMANUPDATE_ON) And _
       (glClientServerMode = HVREMOTE_MODE_SERVER ) Then
        Dbg DBG_EXTRA, "Opening the AZMan policy store"
        lReturn = OpenAuthorizationStore(oAuthStore)
        if lReturn Then
            Error "Giving up as could not open the authorization store"
        end if
    end if ' Open the authorization policy store

    ' Display the Authorization Store
    if (NO_ERROR = lReturn) and _
       (gbShowMode) and _
       (glServerOpAZManUpdate = HVREMOTE_SERVEROP_AZMANUPDATE_ON) And _
       (glClientServerMode = HVREMOTE_MODE_SERVER ) Then
        lReturn = DisplayAuthorizationStore(oAuthStore, gszRoleAssign)
        if lReturn Then Error "Giving up as could not display the authorization store"
    end if ' Display the Authorization Store


    ' Get the localized group name for the "Distributed COM Users" group
    if (NO_ERROR = lReturn) And _
       (glServerOpDCOMPermissions = HVREMOTE_SERVEROP_DCOMPERMISSIONS_ON) And _
       (glClientServerMode = HVREMOTE_MODE_SERVER ) Then
        Dbg DBG_EXTRA, "Getting localized group name for Distributed COM Users"
        lReturn = GetGroupNameForSID (SID_DISTRIBUTED_COM_USERS, szDCOMUsersGroupName)
        Dbg DBG_STD, "Distributed COM Users group name (localized) is '" & szDCOMUsersGroupName & "'"
    end if

    ' Enumerate the Distributed COM Users Group  (Need to be done after have CIMv2 namespace object)
    if (NO_ERROR = lReturn) and _
       (glServerOpDCOMPermissions = HVREMOTE_SERVEROP_DCOMPERMISSIONS_ON) and _
       (gbShowMode) and _
       (0<>(glServerOpNameSpacesToUse And NAMESPACE_CIMv2)) And _
       (glClientServerMode = HVREMOTE_MODE_SERVER ) Then
        Dbg DBG_EXTRA, "Showing the contents of the Distributed COM Users Group"
        lReturn = EnumerateGroupMembers (szDCOMUsersGroupName, oWbemServicesCIMv2)
    end if


    ' New for 0.3 Not just Distributed COM as it could be available through direct SD capability
    ' in the Machine Launch DCOM security permissions
    if (NO_ERROR = lReturn) and _
       (glServerOpDCOMPermissions = HVREMOTE_SERVEROP_DCOMPERMISSIONS_ON) and _
       (gbShowMode) and _
       (0<>(glServerOpNameSpacesToUse And NAMESPACE_CIMv2)) And _
       (glClientServerMode = HVREMOTE_MODE_SERVER ) Then
        Dbg DBG_EXTRA, "Showing the machine Launch Restrictions"
        lReturn = GetMachineRestrictionSDFromRegistry (MACHINE_LAUNCH_RESTRICTION_KEY, oMachineLaunchSD)
        if (NO_ERROR = lReturn) Then
            DisplayWin32SD "COM Security Launch and Activation Permissions", 2, oMachineLaunchSD
        else
            Error "Giving up as failed to get machine launch restriction"
        end if
    end if

    ' If we are adding or removing a user, then we need a Win32_Trustee object for DACL updates. Trustee is part of the ACE.
    if (NO_ERROR = lReturn) and _
       (glServerOpAddRemoveUser<>HVREMOTE_SERVEROP_ADDREMOVEUSER_NONE) And _
       (glClientServerMode = HVREMOTE_MODE_SERVER ) Then
        Dbg DBG_EXTRA, "Have an add or remove - need the trustee objet"
        lReturn = GetTrustee(gszServerOpAddOrRemoveDomainName, gszServerOpAddOrRemoveUserName, oTrustee)
    end if


    ' Add User or group to root\cimv2 namespace permissions
    if (NO_ERROR = lReturn) and _
       (glServerOpAddRemoveUser=HVREMOTE_SERVEROP_ADDREMOVEUSER_ADD) And _
       (0<>(glServerOpNameSpacesToUse And NAMESPACE_CIMv2)) And _
       (glClientServerMode = HVREMOTE_MODE_SERVER ) Then
        wscript.echo ""
        wscript.echo "Adding user or group to root\cimv2 namespace..."
        lReturn = AddACEToDACL(oWin32SDCimv2, oWbemServicesCIMv2, oTrustee)
        select case lReturn
            case ERROR_ALREADY_PRESENT
                 wscript.echo "INFO: No action taken here"
                 lReturn = NO_ERROR
            case NO_ERROR
                wscript.echo "INFO: DACL with user or group ACE built"
                 lReturn = SetWin32SD("root\cimv2", oWin32SDCimv2, oWBemServicesCIMv2)
                 if lReturn Then
                    wscript.echo "Giving up due to error setting security permissions on root\cimv2"
                 else
                    wscript.echo "INFO: root\cimv2 namespace permissions updated OK"
                 end if
            case else
                 wscript.echo "Giving up due to some other error (updating root\cimv2 namespace)"
         end select
    End If

    ' Remove User or group from root\cimv2 namespace permissions
    if (NO_ERROR = lReturn) and _
       (glServerOpAddRemoveUser=HVREMOTE_SERVEROP_ADDREMOVEUSER_REMOVE) And _
       (0<>(glServerOpNameSpacesToUse And NAMESPACE_CIMv2)) And _
       (glClientServerMode = HVREMOTE_MODE_SERVER ) Then

        wscript.echo ""
        wscript.echo "Removing user or group from root\cimv2 namespace..."
        lReturn = RemoveACEFromDACL(oWin32SDCimv2, oWbemServicesCIMv2, oTrustee)
        select case lReturn
            case ERROR_NOT_PRESENT
                 wscript.echo "INFO: No action taken here"
                 lReturn = NO_ERROR
            case NO_ERROR
                wscript.echo "INFO: DACL without user or group ACE in it built"
                lReturn = SetWin32SD("root\cimv2", oWin32SDCimv2, oWBemServicesCIMv2)
                   if lReturn Then
                       wscript.echo "Giving up due to error setting security permissions on root\cimv2"
                   else
                       wscript.echo "INFO: root\cimv2 namespace permissions updated OK"
                   end if
            case else
                 wscript.echo "Giving up due to some other error (updating root\cimv2 namespace)"
         end select
    End If

    ' Add User or group to root\virtualization namespace permissions
    if (NO_ERROR = lReturn) and _
       (glServerOpAddRemoveUser=HVREMOTE_SERVEROP_ADDREMOVEUSER_ADD) And _
       (0<>(glServerOpNameSpacesToUse And NAMESPACE_VIRTUALIZATION)) And _
       (glClientServerMode = HVREMOTE_MODE_SERVER ) Then
        wscript.echo ""
        wscript.echo "Adding user or group to root\virtualization namespace..."
        ' NO - this is not a typo below. It does need the CIMV2 namespace connection
        lReturn = AddACEToDACL(oWin32SDVirtualization, oWbemServicesCIMv2, oTrustee)

        select case lReturn
            case ERROR_ALREADY_PRESENT
                 wscript.echo "INFO: No action taken here"
                 lReturn = NO_ERROR
            case NO_ERROR
                wscript.echo "INFO: DACL with user or group ACE built"
                lReturn = SetWin32SD("root\virtualization", oWin32SDVirtualization, oWBemServicesVirtualization)
                   if lReturn Then
                       wscript.echo "Giving up due to error setting security permissions on root\virtualization"
                   else
                       wscript.echo "INFO: root\virtualization namespace permissions updated OK"
                   end if
            case else
                 wscript.echo "Giving up due to some other error (updating root\virtualization namespace)"
         end select
    End If

    ' Remove User or group from root\virtualization namespace permissions
    if (NO_ERROR = lReturn) and _
       (glServerOpAddRemoveUser=HVREMOTE_SERVEROP_ADDREMOVEUSER_REMOVE) And _
       (0<>(glServerOpNameSpacesToUse And NAMESPACE_VIRTUALIZATION)) And _
       (glClientServerMode = HVREMOTE_MODE_SERVER ) Then
        wscript.echo ""
        wscript.echo "Removing user or group from root\virtualization namespace..."
        ' NO - this is not a typo below. It does need the CIMV2 namespace connection
        lReturn = RemoveACEFromDACL(oWin32SDVirtualization, oWbemServicesCIMv2, oTrustee)

        select case lReturn
            case ERROR_NOT_PRESENT
                 wscript.echo "INFO: No action taken here"
                 lReturn = NO_ERROR
            case NO_ERROR
                wscript.echo "INFO: DACL without user or group ACE in it built"
               ' NO - this is not a typo below. It does need the CIMV2 namespace connection
                lReturn = SetWin32SD("root\virtualization", oWin32SDVirtualization, oWBemServicesVirtualization)
                   if lReturn Then
                       wscript.echo "Giving up due to error setting security permissions on root\virtualization"
                   else
                       wscript.echo "INFO: root\virtualization namespace permissions updated OK"
                   end if
            case else
                 wscript.echo "Giving up due to some other error (updating root\virtualization namespace)"
         end select
    End If

    ' Add User or group to Distributed COM Users
    if (NO_ERROR = lReturn) and _
       (glServerOpDCOMPermissions = HVREMOTE_SERVEROP_DCOMPERMISSIONS_ON) and _
       (glServerOpAddRemoveUser=HVREMOTE_SERVEROP_ADDREMOVEUSER_ADD) And _
       (glClientServerMode = HVREMOTE_MODE_SERVER ) Then
        Dbg DBG_EXTRA, "Adding user to DCOM Users group"
        lReturn = AddUserToGroup(gszServerOpAddOrRemoveDomainName, gszServerOpAddOrRemoveUserName, szDCOMUsersGroupName)
    End If

    ' Remove User or group from Distributed COM Users
    if (NO_ERROR = lReturn) and _
       (glServerOpDCOMPermissions = HVREMOTE_SERVEROP_DCOMPERMISSIONS_ON) and _
       (glServerOpAddRemoveUser=HVREMOTE_SERVEROP_ADDREMOVEUSER_REMOVE) And _
       (glClientServerMode = HVREMOTE_MODE_SERVER ) Then
        Dbg DBG_EXTRA, "Removing user from DCOM Users Group"
        lReturn = RemoveUserFromGroup(gszServerOpAddOrRemoveDomainName, gszServerOpAddOrRemoveUserName, szDCOMUsersGroupName)
    End If

    ' Add or remove user to authorization store
    if (NO_ERROR = lReturn) and _
       (glServerOpAZManUpdate = HVREMOTE_SERVEROP_AZMANUPDATE_ON) And _
       (glClientServerMode = HVREMOTE_MODE_SERVER) And _
       (glServerOpAddRemoveUser<>HVREMOTE_SERVEROP_ADDREMOVEUSER_NONE) Then
        lReturn = AddRemoveAuthorizationStore(oAuthSTore, gszRoleAssign)
    end if

    ' Client side. Add/Remove Anonymous logon to remote DCOM access. First need existing SD
    if (NO_ERROR                =  lReturn) And _
       (glClientServerMode      =  HVREMOTE_MODE_CLIENT) and _
       (glClientOpAnonDCOMMode  <> HVREMOTE_CLIENTOP_ANONDCOM_NONE) Then

        wscript.echo ""
        wscript.echo "INFO: Obtaining current Machine Access Restriction..."  
        lReturn = GetMachineRestrictionSDFromRegistry(MACHINE_ACCESS_RESTRICTION_KEY, oMachineAccessSD)
        if lReturn Then
            wscript.echo "Giving up as unable to obtain machine access restriction security descriptor"
        end if
     end if

    ' Client side. Add Anonymous logon to remote DCOM access. First need existing SD
    if (NO_ERROR                =  lReturn) And _
       (glClientServerMode      =  HVREMOTE_MODE_CLIENT) and _
       (glClientOpAnonDCOMMode  = HVREMOTE_CLIENTOP_ANONDCOM_GRANT) Then
        wscript.echo "INFO: Examining security descriptor"        
        bAnonHasAccess = DoesAnonymousLogonHaveRemoteDCOM(oMachineAccessSD)
        if bAnonHasAccess then
            wscript.echo "INFO: Nothing to do - ANONYMOUS LOGON already has remote access"
        else
            lReturn = AddAnonymousLogonToRemoteDCOM (oWbemServicesCIMv2, oMachineAccessSD)
            if (lReturn) Then
                wscript.echo "Giving up as unable to add anonymous logon to DCOM remote access permission"
            end if
   
        end if
    End if

    ' Client side. Remove Anonymous logon from remote DCOM access. First need existing SD
    if (NO_ERROR                =  lReturn) And _
       (glClientServerMode      =  HVREMOTE_MODE_CLIENT) and _
       (glClientOpAnonDCOMMode  =  HVREMOTE_CLIENTOP_ANONDCOM_REVOKE) Then
        wscript.echo "INFO: Examining security descriptor"  
        bAnonHasAccess = DoesAnonymousLogonHaveRemoteDCOM(oMachineAccessSD)
        if not bAnonHasAccess then
            wscript.echo "INFO: Nothing to do - ANONYMOUS LOGON does not have remote access"
        else
            lReturn = RemoveAnonymousLogonFromRemoteDCOM (oMachineAccessSD)
            if (lReturn) Then
                wscript.echo "Giving up as unable to remove anonymous logon from DCOM remote access permission"
            end if
   
        end if
     End if

     ' Client side. Show anonymous dcom access setting
     if (NO_ERROR = lReturn) And _
        (glClientServerMode = HVREMOTE_MODE_CLIENT) And _
        (gbShowMode) Then
        lReturn = GetMachineRestrictionSDFromRegistry(MACHINE_ACCESS_RESTRICTION_KEY, oMachineAccessSD)

        if NO_ERROR = lReturn Then 
            Call DisplayWin32SD ("COM Security Access Permissions", 2, oMachineAccessSD)
            wscript.echo " "
            wscript.echo "-------------------------------------------------------------------------------"
            wscript.echo "ANONYMOUS LOGON Machine DCOM Access"
            wscript.echo "-------------------------------------------------------------------------------"
            wscript.echo " "

            if DoesAnonymousLogonHaveRemoteDCOM(oMachineAccessSD) Then

                gbAnonDCOMAllowed = True

                if not(gbComputerIsWorkgroup) then

                    wscript.echo "WARN: ANONYMOUS LOGON does have remote access"
                    wscript.echo " "
                    wscript.echo "  This setting should only be enabled if required as security on this "
                    wscript.echo "  machine has been lowered. It is needed if you need to manage Hyper-V"
                    wscript.echo "  on a remote server which is either in an an untrusted domain from this"
                    wscript.echo "  machine, or both machines are in a workgroup."
                    wscript.echo ""
                    wscript.echo "  Use hvremote /mode:client /anondcom:revoke to turn off"
                    glWarns = glWarns + 1
                    gszWarns = gszWarns & glWarns & ": Anonymous Logon has remote access (may be ok)" & vbcrlf
                else
                    wscript.echo "ANONYMOUS LOGON has remote access"
                end if


            else

                gbAnonDCOMAllowed = False

                ' 0.7 Additional message
                if(gbComputerIsWorkgroup) then
                    wscript.echo "WARN: ANONYMOUS LOGON does not have remote access"
                    wscript.echo " "
                    wscript.echo "  This setting is required when the client is in a workgroup, or the"
                    wscript.echo "  server is in an untrusted domain from the client."
                    wscript.echo ""
                    wscript.echo "  Use hvremote /mode:client /anondcom:grant to turn on"

                    glWarns = glWarns + 1
                    gszWarns = gszWarns & glWarns & ": Anonymous Logon does not have remote access" & vbcrlf

                else
                    wscript.echo "ANONYMOUS LOGON does not have remote access"
                    wscript.echo " "
                    wscript.echo "  This setting should only be enabled if required as security on this "
                    wscript.echo "  machine will be lowered. This computer is in a domain. It is not "
                    wscript.echo "  required if the server(s) being managed are in the same or trusted"
                    wscript.echo "  domains."
                    wscript.echo ""
                    wscript.echo "  Use hvremote /mode:client /anondcom:enable to turn on"
                    glWarns = glWarns + 1
                    gszWarns = gszWarns & glWarns & ": Anonymous Logon does not have remote access (may be ok)" & vbcrlf

                end if
            end if
         end if

      end if
                 
     ' Client side. Show firewall policies?
     if (NO_ERROR = lReturn) And _
        (glClientServerMode = HVREMOTE_MODE_CLIENT) And _
        (gbShowMode) Then
         lReturn = ShowFirewallPolicyForGroup (HVREMOTE_CLIENTOP_FIREWALL_HYPERVMGMTCLIENT_RESOURCE, "Hyper-V Management Clients", True, True)
     end if

     ' Client side. Show MMC firewall exceptions?
     if (NO_ERROR = lReturn) And _
        (glClientServerMode = HVREMOTE_MODE_CLIENT) And _
        (gbShowMode) Then
         lReturn = ShowMMCFirewallRules()
     end if


     ' New 0.7 For client side, before message about cmdkey, look to see whether the
     ' target machine is in the same domain as the client. We do this silently.
     ' Can only be done if the user has specified a target machine. We also check
     ' for a v1 client connected to an R2 level server which is not supported.
     if (NO_ERROR = lReturn) And _
        (glClientServerMode = HVREMOTE_MODE_CLIENT) And _
        (gbShowMode) and _
        (gbTestConnectivity) Then
         lReturn = GetRemoteServerInfo(bIsTargetInDomain, szDomainOfTarget, szBuildOfTarget)
         ' Only do domain check if target and client are both known to be domain joined
         if NO_ERROR = lReturn and _
            (bIsTargetInDomain) and _
            (not gbComputerIsWorkgroup) and _
            (lcase(gszLocalComputerDomainName) = lcase(szDomainOfTarget)) then
            Dbg DBG_EXTRA, "Both computers are in the same domain"
            bBothComputersAreInSameDomain = True
         end if

         ' Check if client is v1 but connected to an R2 server - not supported
         if NO_ERROR = lReturn and _
            (gbRunningOnWin7 = False) and _
            (len(szBuildOfTarget)) and _
            (instr(szBuildOfTarget,".")>0) Then
            Dbg DBG_EXTRA, "Target build=" & szBuildOfTarget
            arrBuildOfTarget = split(szBuildOfTarget,".")
            if ubound(arrBuildOfTarget) = 2 then
                if arrBuildOfTarget(0) = 6 and arrBuildOfTarget(1) = 1  then
                    glWarns = glWarns + 1
                    gszWarns = gszWarns & glWarns & ": Microsoft does not support your configuration - you are running a" & vbcrlf & _
                                                    "   'v1' (Vista/Server 2008) client against a 2008 R2 server. You should use" & vbcrlf & _        
                                                    "   a Windows 7 or Server 2008 R2 full installation as your client." & vbcrlf
                end if
            end if
         end if

         ' Silent - Don't fail
         if lReturn then lReturn = NO_ERROR
     end if


     ' Client side. Message about cmdkey....
     if (NO_ERROR = lReturn) And _
        (glClientServerMode = HVREMOTE_MODE_CLIENT) And _
        not(gbComputerIsWorkgroup) and _
        (gbShowMode) and _
        (not bBothComputersAreInSameDomain) Then



         wscript.echo " "
         wscript.echo "-------------------------------------------------------------------------------"
         wscript.echo "Additional configuration may be necessary"
         wscript.echo "-------------------------------------------------------------------------------"
         wscript.echo " "
         wscript.echo "  This computer is in a domain. If the target server is in a workgroup, "
         wscript.echo "  you may need to set credentials for the server for Hyper-V Remote "
         wscript.echo "  Management to operate correctly. This step should not be necssary if"
         wscript.echo "  the target server is in the same or trusted domain as this computer."
         wscript.echo " "
         wscript.echo "  If necessary, from a *NON* elevated command prompt, enter:"
         wscript.echo " "
         wscript.echo "     cmdkey /add:ServerComputerName /user:ServerComputerName\UserName /pass"
         wscript.echo " "
         wscript.echo "  Note that you MUST enter ServerComputerName to BOTH parameters."
         wscript.echo "  You will be prompted for a password after entering the command."
         wscript.echo " "
         glWarns = glWarns + 1
         gszWarns = gszWarns & glWarns & ": You *may* need to set credentials for access to the server" & vbcrlf

     end if
     


     ' Client side. Change firewall policies for the HyperVManagementClient?
     if (NO_ERROR = lReturn) And _
        (glClientServerMode = HVREMOTE_MODE_CLIENT) And _
        (glClientOpFirewallHyperVMgmtClient <> HVREMOTE_CLIENTOP_FIREWALL_HYPERVMGMTCLIENT_NONE) Then

         lReturn = ChangeFirewallPolicyForGroup ( HVREMOTE_CLIENTOP_FIREWALL_HYPERVMGMTCLIENT_RESOURCE, _
                                                  (glClientOpFirewallHyperVMgmtClient = HVREMOTE_CLIENTOP_FIREWALL_HYPERVMGMTCLIENT_ALLOW))

     end if

     ' Client side. Enable firewall policies for the MMC Exception?
     if (NO_ERROR = lReturn) And _
        (glClientServerMode = HVREMOTE_MODE_CLIENT) And _
        (glClientOpFirewallMMCException = HVREMOTE_CLIENTOP_FIREWALL_MMCEXCEPTION_ALLOW) Then
         lReturn = SetMMCFirewallRules(True)
     end if


     ' Client side. Disable firewall policies for the MMC Exception?
     if (NO_ERROR = lReturn) And _
        (glClientServerMode = HVREMOTE_MODE_CLIENT) And _
        (glClientOpFirewallMMCException = HVREMOTE_CLIENTOP_FIREWALL_MMCEXCEPTION_DENY) Then
         lReturn = SetMMCFirewallRules(False)
     end if

     ' Client side. Tracing On (New 0.7)
     if (NO_ERROR = lReturn) And _
        (glClientServerMode = HVREMOTE_MODE_CLIENT) And _
        (glClientOpTracing = HVREMOTE_CLIENTOP_TRACING_ON) Then
         lReturn = ConfigureClientTracingOn()
     end if

     ' Client side. Tracing Off (New 0.7)
     if (NO_ERROR = lReturn) And _
        (glClientServerMode = HVREMOTE_MODE_CLIENT) And _
        (glClientOpTracing = HVREMOTE_CLIENTOP_TRACING_OFF) Then
         lReturn = ConfigureClientTracingOff()
     end if

     ' Server side. Show firewall policies?
     if (NO_ERROR = lReturn) And _
        (glClientServerMode = HVREMOTE_MODE_SERVER) And _
        (gbShowMode) Then
        ' Drop through ignore RC
        if gbRunningOnWin7 Then
            Call ShowFirewallPolicyForGroup (HVREMOTE_SERVEROP_FIREWALL_HYPERV_RESOURCE_WIN7, "Hyper-V", True, True)
        else
            Call ShowFirewallPolicyForGroup (HVREMOTE_SERVEROP_FIREWALL_HYPERV_RESOURCE_V1, "Hyper-V", True, True)
        end if

        Call ShowFirewallPolicyForGroup(HVREMOTE_SERVEROP_FIREWALL_WMIMGMT_RESOURCE,"Windows Management Instrumentation (WMI)", False, False)
        wscript.echo " "
        wscript.echo "Note: Above firewall settings are not required for Hyper-V Remote Management"
     end if

     ' Server side. CHange firewall policies for Hyper-V Server-side configuration?
     if (NO_ERROR = lReturn) And _
        (glClientServerMode = HVREMOTE_MODE_SERVER) And _
        (glServerOpFirewallHyperV <> HVREMOTE_SERVEROP_FIREWALL_HYPERV_NONE) Then
        if gbRunningOnWin7 Then
            lReturn = ChangeFirewallPolicyForGroup ( HVREMOTE_SERVEROP_FIREWALL_HYPERV_RESOURCE_WIN7, _
                                                   (glServerOpFirewallHyperV = HVREMOTE_SERVEROP_FIREWALL_HYPERV_ALLOW))
        else
            lReturn = ChangeFirewallPolicyForGroup ( HVREMOTE_SERVEROP_FIREWALL_HYPERV_RESOURCE_v1, _
                                                   (glServerOpFirewallHyperV = HVREMOTE_SERVEROP_FIREWALL_HYPERV_ALLOW))
        end if
     end if


     ' Server side. Change firewall policies for remote WMI management
     if (NO_ERROR = lReturn) And _
        (glClientServerMode = HVREMOTE_MODE_SERVER) And _
        (glServerOpFirewallWMIMgmt <> HVREMOTE_SERVEROP_FIREWALL_WMIMGMT_NONE) Then
        lReturn = ChangeFirewallPolicyForGroup ( HVREMOTE_SERVEROP_FIREWALL_WMIMGMT_RESOURCE, _
                                               (glServerOpFirewallWMIMgmt = HVREMOTE_SERVEROP_FIREWALL_WMIMGMT_ALLOW))
     end if


    ' Message about possible restart if adding
    if (NO_ERROR = lReturn) and _
       (glServerOpAddRemoveUser=HVREMOTE_SERVEROP_ADDREMOVEUSER_ADD) And _
       (glClientServerMode = HVREMOTE_MODE_SERVER ) Then
        wscript.echo ""
        wscript.echo "NOTE: If this is the first time you have used HVRemote " 
        wscript.echo "to add a user for remote configuration, it may be necessary"
        wscript.echo "to restart this machine. See documentation for further "
        wscript.echo "information."
    End If



    ' Server and Client (v0.4) I'm always needing IPConfig output, so easier to just include it
    if (NO_ERROR = lReturn) and (gbShowMode) Then
        lReturn = IPConfig()
    end if

     ' Client side. (v0.4) Are there cmdkey exceptions in place?
     if (NO_ERROR = lReturn) And _
        (glClientServerMode = HVREMOTE_MODE_CLIENT) And _
        (gbShowMode) Then
         lReturn = CmdKey()
     end if


    ' Client side (v0.7) Test connectivity to a target server?
    if (NO_ERROR = lReturn) and _
       (glClientServerMode = HVREMOTE_MODE_CLIENT) And _
       (gbShowMode) And _
       (gbTestConnectivity) THen
        lReturn = TestCallsToServer()
        lReturn = NO_ERROR ' Don't worry if fails
    end if

    ' Server side (v0.7) Test connectivity to a target client?
    if (NO_ERROR = lReturn) and _
       (glClientServerMode = HVREMOTE_MODE_SERVER) And _
       (gbShowMode) And _
       (gbTestConnectivity) THen
        lReturn = TestCallsToClient()
        lReturn = NO_ERROR ' Don't worry if fails
    end if

 
    ' Check for latest version
    if (NO_ERROR = lReturn) and (gbVersionCheck) Then
        lReturn = AmILatestVersion ("http://blogpics.dyndns.org/HVRemote-Latest-Version.txt")
        if lReturn = -2 Then ' Not located - alternate location
            lReturn = AmILatestVersion ("http://blogs.technet.com/jhoward/pages/hvremotelatestversion.aspx")
        end if
        lReturn = NO_ERROR
    End If

    if (glWarns) Then
        wscript.echo ""
        wscript.echo "-------------------------------------------------------------------------------"
        wscript.echo glWarns & " warning(s) or error(s) were found in the configuration. Review the "
        wscript.echo "detailed output above to determine whether you need to take further action."
        wscript.echo "Summary is below."
        wscript.echo " "
        wscript.echo gszWarns
        wscript.echo "-------------------------------------------------------------------------------"
    end if


    ' Client side (v0.7) Warning of no connectivity test
    if (NO_ERROR = lReturn) and _
       (glClientServerMode = HVREMOTE_MODE_CLIENT) And _
       (gbShowMode) And _
       (not gbTestConnectivity) THen
        wscript.echo ""
        wscript.echo ""
        wscript.echo ""
        wscript.echo "-------------------------------------------------------------------------------"
        wscript.echo "Did you know.... HVRemote can help diagnose common errors?"
        wscript.echo ""
        wscript.echo " Instead of running HVRemote /show, run HVRemote /show /target:servername."
        wscript.echo " This runs a series of tests against the server to verify connectivity."
        wscript.echo ""
        wscript.echo " Note that there is documentation on the HVRemote site to assist with the"
        wscript.echo " most commonly asked questions. Please consult that before asking for"
        wscript.echo " assistance."
        wscript.echo "-------------------------------------------------------------------------------"
    end if

    ' Server side (v0.7) Warning of no connectivity test
    if (NO_ERROR = lReturn) and _
       (glClientServerMode = HVREMOTE_MODE_SERVER) And _
       (gbShowMode) And _
       (not gbTestConnectivity) THen
        wscript.echo ""
        wscript.echo ""
        wscript.echo ""
        wscript.echo "-------------------------------------------------------------------------------"
        wscript.echo "Did you know.... HVRemote can help diagnose common errors?"
        wscript.echo ""
        wscript.echo " Instead of running HVRemote /show, run HVRemote /show /target:clientname."
        wscript.echo " This runs tests against the client to verify potential connectivity issues."
        wscript.echo ""
        wscript.echo " Note that there is documentation on the HVRemote site to assist with the"
        wscript.echo " most commonly asked questions. Please consult that before asking for"
        wscript.echo " assistance."
        wscript.echo "-------------------------------------------------------------------------------"
    end if


 

    ' ********************************************************************
    ' * Logs a debug message. In a function in case I change to file logging some time...
    ' ********************************************************************
     Function Dbg (lLevel, szMessage)
         if (lLevel <= glDebugLevel) Then wscript.echo "DEBUG: " & szMessage
     End Function


    ' ********************************************************************
    ' * Displays and error. In a function in case I change it to log to file some time...
    ' ********************************************************************
     Function Error (szMessage)
        wscript.echo  "***** " & szMessage
     End Function


    ' ********************************************************************
    ' * IsRoleInstalled: Looks for VMMS Service present on target
    ' * A bit simplistic, but good enough.
    ' ********************************************************************
    Function IsRoleInstalled(oConnection)

        Dim colServices         ' Collection of services on the box
        Dim oService            ' For enumerating the services
        Dim lReturn             ' Function return value

        On error resume next

        lReturn = NO_ERROR
        IsRoleInstalled = False
        set colServices = Nothing
        set oService = Nothing

        if (NO_ERROR = lReturn) Then
            set colServices = oConnection.ExecQuery("select * from win32_service where name='VMMS'")
            if err.number Then
                Error "Failed to query services"
                Error err.description & " " & err.number
                wscript.quit
            end if
        end if


        if (NO_ERROR = lReturn) Then
            if colServices.Count = 1 then 
                IsRoleInstalled = True
            end if
        end if

        set colServices = Nothing
        set oService = Nothing

    End Function ' IsRoleInstalled


    ' ********************************************************************
    ' * DoClientChecks: SKU and KB checks on Vista/Windows 7
    ' ********************************************************************
    Function DoClientChecks(oConnection) ' Connection to CIMv2 namespace

        Dim colOSs                     ' Collection of win32_operatingsystem instances
        Dim aVersion                   ' For splitting the .version property
        Dim oOS                        ' For enumerating the collection
        Dim lReturn                    ' Function return value
        Dim szProgramFiles             ' Environment %ProgramFiles%


        On error resume next

        ' Vista SP1 x64  Version: 6.0.6001 / Service Pack: 1.0
        ' 2K8 (SP1) x64  Version: 6.0.6001 / Service Pack: 1.0
        ' 2K8 (SP2 Beta) Version: 6.0.6002 / Service Pack: 2.0
        ' Win7 Client    Version: 6.1.7600 / Service Pack: 0.0
        ' 2K8 R2         Version: 6.1.7600 / Service Pack: 0.0

        lReturn = NO_ERROR
        szProgramFiles = ""
        set colOSs = Nothing
        set oOS = Nothing

        set colOSs = oConnection.ExecQuery("select * from win32_operatingsystem")


        if (err.number = 0) Then
             for each oOS in colOSs

                ' Fix in 0.6
                ' Bail out if we aren't on a client SKU
                ' 1=Ultimate; 2=HomeBasic; 3=HomeBasicPremium; 4=Enterprise; 5=HomeBasicN; 6=Business;
                ' 11=Starter; 16=BusinessN; 
                if (oOS.OperatingSystemSKU <> 1) and _
                   (oOS.OperatingSystemSKU <> 2) and _
                   (oOS.OperatingSystemSKU <> 3) and _
                   (oOS.OperatingSystemSKU <> 4) and _
                   (oOS.OperatingSystemSKU <> 5) and _
                   (oOS.OperatingSystemSKU <> 6) and _
                   (oOS.OperatingSystemSKU <> 11) and _         
                   (oOS.OperatingSystemSKU <> 16) Then
                    wscript.echo "INFO: This appears to be a server SKU"
                    Exit function
                end if

                aVersion = split(oOS.Version,".")

                ' Vista Version
                if CLng(aVersion(0)) = 6 and _
                   CLng(aVersion(1)) = 0 Then
                    ' http://msdn.microsoft.com/en-us/library/aa394239(VS.85).aspx
                    ' 2=HomeBasic; 3=HomeBasicPremium; 5=HomeBasicN; 11=Starter
                    if (oOS.OperatingSystemSKU = 2) or _
                       (oOS.OperatingSystemSKU = 3) or _
                       (oOS.OperatingSystemSKU = 5) or _
                       (oOS.OperatingSystemSKU = 11) Then
                        Error ""
                        Error "The Vista SKU you are using does not support Hyper-V Remote Management"
                        Error "SKU ID Found is " & oOS.OperatingSystemSKU
                        Error "SKU info on http://msdn.microsoft.com/en-us/library/aa394239(VS.85).aspx"
                        wscript.quit
                    end if
                    

                    ' KB952627 check - v1 RTM Management Update
                    if IsQFEInstalled(oConnection, "952627") then
                        wscript.echo "INFO: This machine has Hyper-V Management Client installed (KB952627)"
                    else
                        Error ""
                        Error "You need to install KB952627 for Hyper-V Remote Management from Vista"
                        Error "http://support.microsoft.com/kb/952627"
                        wscript.quit
                    end if


                    ' KB970203 check for Vista SP2 - update to Management bits
                    if CLng(aVersion(2)) = 6002 then
                        if IsQFEInstalled(oConnection, "970203") then
                            wscript.echo "INFO: Found recommended update KB970203"
                        else
                            glWarns = glWarns + 1
                            gszWarns = gszWarns & glWarns & ": Recommended update KB970203 is not installed" & vbcrlf
                        end if
                    end if ' End of Vista SP2 check

                end if


                'TODO: About as complete as I can currently get before GA

                ' Windows 7 Version
                ' Note: Here we don't quit though. MSDN docs aren't updated yet.
                if CLng(aVersion(0)) = 6 and _
                   CLng(aVersion(1)) = 1 Then
                    ' http://msdn.microsoft.com/en-us/library/aa394239(VS.85).aspx
                    ' 2=HomeBasic; 3=HomeBasicPremium; 5=HomeBasicN; 11=Starter
                    if (oOS.OperatingSystemSKU = 2) or _
                       (oOS.OperatingSystemSKU = 3) or _
                       (oOS.OperatingSystemSKU = 5) or _
                       (oOS.OperatingSystemSKU = 11) Then
                        Error ""
                        Error "The Windows 7 SKU you are using does not support Hyper-V Remote Management"
                        Error "SKU ID Found is " & oOS.OperatingSystemSKU
                        Error "SKU info on http://msdn.microsoft.com/en-us/library/aa394239(VS.85).aspx"
 
                        glWarns = glWarns + 1
                        gszWarns = gszWarns & glWarns & ": This Windows 7 edition does not support the Hyper-V Tools" & vbcrlf


                        ' TODO: wscript.quit once have confirmation of SKUs
                    end if


                    if IsQFEInstalled(oConnection, "958830") then                    
                        wscript.echo "INFO: Remote Server Administration Tools are installed"
                    else

                        ' TODO: Put actual link in once live.

                        wscript.echo ""
                        Error "You may need to install an update for RSAT (Remote Server"
                        Error "Administration Tools) for Windows 7. You will find this"
                        Error "on the Microsoft Download Centre."
                        Error ""
                        Error "http://www.microsoft.com/downloads"
                        wscript.echo ""

                        glWarns = glWarns + 1
                        gszWarns = gszWarns & glWarns & ": RSAT does not appear to be installed" & vbcrlf

                        exit function
                    end if


                    Call GetEnvironmentVariable("ProgramFiles", szProgramFiles)
                    if len(szProgramFiles) Then
                        if not(FileExists(szProgramFiles & "\Hyper-V\virtmgmt.msc")) then
                            wscript.echo ""
                            Error "RSAT is installed, but you need to enable a Windows feature to"
                            Error "run the Hyper-V Remote Management tools:"
                            Error ""
                            Error " - Start/Control Panel"
                            Error " - Click 'Programs'"
                            Error " - Click 'Turn Windows features on or off'"
                            Error " - Expand the tree to check 'Hyper-V Tools' under"
                            Error "   Remote Server Administration Tools/Role Administration Tools"
                            Error " - Click OK to enable the feature."
                            Error ""
                            Error "Once the feature is enabled, Hyper-V Manager will be"
                            Error "located under Administrative Tools."
                            wscript.echo ""

                            glWarns = glWarns + 1
                            gszWarns = gszWarns & glWarns & ": Hyper-V Tools are not enabled" & vbcrlf
 
                            wscript.quit
                        else
                            wscript.echo "INFO: Hyper-V Tools Windows feature is enabled"
                        end if
                     else
                        glWarns = glWarns + 1
                        gszWarns = gszWarns & glWarns & ": Unable to determine %programfiles%" & vbcrlf
                     end if
                end if
             next
        end if


        set colOSs = Nothing
        set oOS = Nothing

    End Function



    ' ********************************************************************
    ' * RunningOnWin7: Returns true if Win7 (or later). Also sets SP major level
    ' ********************************************************************
    Function RunningOnWin7(oConnection) ' Connection to CIMv2 namespace

        Dim colOSs                     ' Collection of win32_operatingsystem instances
        Dim aVersion                   ' For splitting the .version property
        Dim oOS                        ' For enumerating the collection
        Dim lReturn                    ' Function Return Value
        Dim oReg                       ' StdRegProv to query registry
        Dim szBuildLabEx               ' Build string

        RunningOnWin7 = False
 
        On error resume next


        ' 0.7 new code to dump the build number
        lReturn = NO_ERROR
        set oReg = Nothing

        Dbg DBG_STD, "RunningOnWin7:Enter"

        ' Need StdRegProv to access the registry
        if (NO_ERROR = lReturn) Then
            Dbg DBG_STD, "RunningOnWin7: Instantiate StdRegProv"
            set oReg=GetObject("winmgmts:{impersonationLevel=impersonate}!\\.\root\default:StdRegProv")
            if (err.number) or (oReg is Nothing) Then
                Error "RunningOnWin7 failed: Could not instantiate StdRegProv"
                Error err.number & " " & err.description
                lReturn = -1
            end if
        end if

        ' Get the BuildLabEx string
        if (NO_ERROR = lReturn) then
            Dbg DBG_STD, "RunningOnWin7: GetStringValue"
            lReturn = oReg.GetStringValue (HKEY_LOCAL_MACHINE, _
                                           "Software\Microsoft\Windows NT\CurrentVersion", _
                                           "BuildLabEx", _
                                           szBuildLabEx)
            if (err.number) or (lReturn) Then 
                Error "RunningOnWin7 failed: Failed to query registry"
                Error err.number & " " & err.description
                lReturn = -1
            else
                wscript.echo "INFO: Build " & szBuildLabEx
            end if
        end if

        ' Vista SP1 x64  Version: 6.0.6001 / Service Pack: 1.0
        ' 2K8 (SP1) x64  Version: 6.0.6001 / Service Pack: 1.0
        ' 2K8 (SP2 Beta) Version: 6.0.6002 / Service Pack: 2.0
        ' Win7 Client    Version: 6.1.7600 / Service Pack: 0.0
        ' 2K8 R2         Version: 6.1.7600 / Service Pack: 0.0


        set colOSs = oConnection.ExecQuery("select * from win32_operatingsystem")
        if (err.number = 0) Then
             for each oOS in colOSs
                glServicePack = oOS.ServicePackMajorVersion
                aVersion = split(oOS.Version,".")
                if CLng(aVersion(0)) < 6 then
                    wscript.echo "Cannot run pre-Vista/Windows Server 2008"
                    wscript.quit
                end if
                if CLng(aVersion(0)) > 6 then
                    wscript.echo "WARN: Running on a later OS version than tested."
                    RunningOnWin7 = True
                    glWarns = glWarns + 1
                    gszWarns = gszWarns & glWarns & ": Running on a later OS than tested on" & vbcrlf
                    exit function
                end if
                ' Must be 6.x:  6.0=Vista/Longhorn
                if CLng(aVersion(1)) = 0 then
                    RunningOnWin7 = False
                    ' And must be SP1 (Vista). There is no Longhorn "SP0" RTM.
                    if glServicePack < 1 THen
                        Error "Must have Vista SP1 for Hyper-V Remote Management"
                        wscript.quit
                    end if
                    exit function
                end if
                if CLng(aVersion(1)) = 1 Then
                    RunningOnWin7 = True
                    ' 0.7 New Code to detect RTM builds
                    if CLng(aVersion(2)) < 7600 then
                       wscript.echo "WARN: This is a pre-release version of Windows 7/Windows Server 2008 R2"
                       glWarns = glWarns + 1
                       gszWarns = gszWarns & glwarns & ": Pre-release operating systems are not supported" & vbcrlf      
                    end if
                    exit Function
                end if
                if CLng(aVersion(1)) >1 Then
                    RunningOnWin7 = True
                    wscript.echo "WARN: Running on an unrecognised OS release. Assuming Win7"
                    glWarns = glWarns + 1
                    gszWarns = gszWarns & glWarns & ": Running on an unknown OS release" & vbcrlf
                    exit Function
               end if
            next
        end if

        set oReg = Nothing

    End Function

    ' ********************************************************************
    ' * ComputerIsWorkgroup: In a workgroup returns true
    ' ********************************************************************
    Function ComputerIsWorkgroup()

        ' Quick and dirty function. Not optimal but does the trick.
        ComputerIsWorkgroup = False

        Dim oProcess          ' For the process environment variables
        Dim oCS               ' Local win32_computersystem object
        Dim lReturn           ' Function return value
        Dim oNetwork          ' For getting the currently logged on user

        On error resume next

        set WshShell = Nothing
        set oProcess = Nothing
        set oCS = Nothing

        ' Assume not
        ComputerIsWorkgroup = False

        ' Get the computername
        if (NO_ERROR = lReturn) Then
            Call GetEnvironmentVariable("COMPUTERNAME", gszLocalComputerName)
            if (err.number) or (0 = len(gszLocalComputerName)) Then
                Error "Failed to obtain COMPUTERNAME from environment"
                Error err.description & " " & err.number
                lReturn = -1
                wscript.quit
            else
                wscript.echo "INFO: Computername is " & gszLocalComputerName
            end if
        end if

        ' Get the computer system object from WMI
        if (NO_ERROR = lReturn) Then
            set oCS = GetObject("winmgmts:{impersonationLevel=impersonate}!\\.\root\cimv2:Win32_ComputerSystem.Name='" & gszLocalComputerName & "'")
            if (err.number) or (oCS is nothing) Then
                Error "Failed to GetObject for Win32_ComputerSystem of current computer"
                Error err.description & " " & err.number
                lReturn = -1
                wscript.quit
            end if
        end if

        if (NO_ERROR = lReturn) Then
            if Not IsNull(oCS.Workgroup) THen 
                ComputerIsWorkgroup = True
                wscript.echo "INFO: Computer is in workgroup " & oCS.Workgroup
            else
                wscript.echo "INFO: Computer is in domain " & oCS.Domain
                gszLocalComputerDomainName = lcase(ocs.domain)
            end if
        end if



        if (NO_ERROR = lReturn) Then
             set oNetwork = CreateObject("WScript.network")
             if (err.number) or (oNetwork is nothing) Then
                 Error "Failed to create wscript.network"
                 Error err.description & " " & err.number
                 lReturn = -1
                 wscript.quit
             else
                 wscript.echo "INFO: Current user is " & oNetwork.UserDomain & "\" & oNetwork.UserName
             end if
        end if
            
        set oProcess = Nothing
        set oCS = Nothing
        set oNetwork = Nothing

    End Function




    ' ********************************************************************
    ' * DisplayAuthorizationStore: Dumps out AZMan policy store
    ' ********************************************************************
    Function DisplayAuthorizationStore(oAuthStore, szRoleAssignment)

        Dim lReturn
        Dim oApplication            ' The Application Object
        Dim oOperation              ' For enumerating the operations in the policy store
        Dim colOperations           ' The collection of all operations in the policy store
        Dim colRoleAssignments      ' The collection of all role assignments in the policy store. Default 1 'Administrators'
        Dim oRoleAssignment         ' For enumerating the role assignments in the policy store
        Dim lIndex                  ' For enumerating operations
        Dim arrOperations           ' For extracting operations from roleassignment.roledefinition.operations 
        Dim bRoleAssignmentFound    ' Is the requested role assignment present in the policy store?
        Dim iRoleAssignmentCount    ' For iterating the role assignments

        On error resume next

        lReturn = NO_ERROR
        bRoleAssignmentFound = FALSE
        set oApplication = NOthing
        set oOperation = Nothing
        set oRoleAssignment = Nothing

        wscript.echo " "
        wscript.echo "-------------------------------------------------------------------------------"
        wscript.echo "Contents of Authorization Store Policy"
        wscript.echo "-------------------------------------------------------------------------------"
        wscript.echo " "

        wscript.echo "Hyper-V Registry configuration:"
        wscript.echo "- Store: " & gszAuthStore
        wscript.echo "- Service Application: " & gszAuthStoreServiceApplication
        wscript.echo " "

        ' Verify the number of applications. Should be 1.
        If (NO_ERROR = lReturn) Then
            If 1 <> oAuthStore.Applications.Count Then
                Error "ERROR: Should be 1 application in policy store. There are " & oAuthStore.Applications.Count
                lReturn = -1
            Else
                wscript.echo "Application Name: " & oAuthStore.Applications.Item(1).Name
                if lcase(gszAuthStoreServiceApplication) <> lcase (oAuthStore.Applications.Item(1).Name) Then
                    Error "Authorization store is not the configured Hyper-V Authorization store."
                    Error "It should contain application '" & gszAuthStoreServiceApplication & "'"
                    Error "It actually contains " & oAuthStore.Applications.Item(1).Name
                    lReturn = -1
                else
                    Set oApplication = oAuthStore.OpenApplication(gszAuthStoreServiceApplication)
                    if (err.number) or (oApplication is nothing) Then
                        Error "Failed to open application in authorization store"
                        Error err.number & " " & err.description
                        lReturn = -1
                    end if
                end if
            End If
        End If

        ' Dump the entire set of operations
        If (NO_ERROR = lReturn) Then
            wscript.echo "Operation Count: " & oApplication.Operations.Count
            wscript.echo " "
            Set colOperations = oApplication.Operations
            For Each oOperation In colOperations
                wscript.echo "    " & oOperation.OperationID & " - " & oOperation.Name
            Next
            wscript.echo " "
        End If

        ' How many Role Assignments are defined? (Default is Administrators only)
        If (NO_ERROR = lReturn) Then
            wscript.echo oAuthStore.Applications.Item(1).RoleAssignments.Count & " role assignment(s) were located"
            Set colRoleAssignments = oApplication.RoleAssignments
            If oApplication.RoleAssignments.Count = 0 Then
                wscript.echo "ERROR: The policy store has no role assignments!"
                lReturn = -1
            End If
        End If


        If (NO_ERROR = lReturn) Then


            For iRoleAssignmentCount = 1 to oApplication.RoleAssignments.Count

                set oRoleAssignment = oApplication.OpenRoleAssignment(oApplication.RoleAssignments(iRoleAssignmentCount).Name)
                wscript.echo " "
                Dim szTemp
                szTemp = "Role Assignment '" & oRoleAssignment.Name & "' "
                If LCase(oRoleAssignment.Name) = LCase(szRoleAssignment)Then
                   szTemp = szTemp & "(Targetted Role Assignment)"
                   bRoleAssignmentFound = True
                End If
                wscript.echo szTemp

                If (oRoleAssignment.RoleDefinitions.Count < 1) Then
                     Error "ERROR: Cannot handle RoleAssignment which doesn't have only one Role Definition!!!"
                     wscript.Quit
                Else
                    
                    arrOperations = oRoleAssignment.RoleDefinitions.Item(1).Operations
                    
                    if ubound(arrOperations) + 1 < oApplication.Operations.Count then
                        wscript.echo "   WARN: Only the following operations are present in this role definition"
                        For lIndex = 0 To UBound(arrOperations)
                            wscript.echo "   - " & arrOperations(lIndex)
                        Next
                        glWarns = glWarns + 1
                        gszWarns = gszWarns & glWarns & ": Some operations are not present in AZMan" & vbcrlf
                    else
                        wscript.echo "   - All Hyper-V operations are selected"
                    end if

                    ' Note to self. This is the most bizarre object model I've ever dealt with.
                    ' Cannt access through oRoleAssignment.Members(n), but assigning a local array seems to work. 
                    ' Ugh. Oh, and can get ubound property. Most odd.

                    wscript.echo "   - There are " & UBound(oRoleAssignment.Members)+1 & " member(s) for this role assignment"
                    wscript.echo " "
                    Dim arrMembers, arrMembersName
                    arrMembers = oRoleAssignment.Members
                    arrMembersName = oRoleAssignment.MembersName
                    Dim x
                    for x = 0 to ubound(arrMembers)
                       wscript.echo "   - " & arrMembersName(x) & " (" & arrMembers(x) & ")"
                    next
                
                End If
            Next
        End If

        if (NO_ERROR = lReturn) Then
            if (not bRoleAssignmentFound) Then 
               wscript.echo "WARN: Role Assignment '" & szRoleAssignment & "' is not in policy store"
               glWarns = glWarns + 1
               gszWarns = gszWarns & glWarns & ": Role assignment not found in policy store" & vbcrlf
            end if
        end if

        set oApplication = NOthing
        set oOperation = Nothing
        set oRoleAssignment = Nothing
        set colRoleAssignments = Nothing
        set colOperations = Nothing

        DisplayAuthorizationStore=lReturn

    End Function ' DisplayAuthorizationStore


    ' ********************************************************************
    ' * OpenAuthorizationStore: Reads registry and opens auth store
    ' ********************************************************************
    Function OpenAuthorizationStore(byref oAuthStore)
        On error resume next

        Dim lReturn           ' Function Return Value
        Dim oReg              ' StdRegProv to query registry

        On error resume next

        lReturn = NO_ERROR
        set oReg = Nothing
        set oAuthStore = Nothing

        Dbg DBG_STD, "OpenAuthorizationStore: Enter"

        ' Need StdRegProv to access the registry
        if (NO_ERROR = lReturn) Then
            Dbg DBG_STD, "OpenAuthorizationStore: Instantiate StdRegProv"
            set oReg=GetObject("winmgmts:{impersonationLevel=impersonate}!\\.\root\default:StdRegProv")
            if (err.number) or (oReg is Nothing) Then
                Error "OpenAuthorizationStore failed: Could not instantiate StdRegProv"
                Error err.number & " " & err.description
                lReturn = -1
            end if
        end if

        ' Get the Path to the store
        if (NO_ERROR = lReturn) then
            Dbg DBG_STD, "OpenAuthorizationStore: GetStringValue"
            lReturn = oReg.GetStringValue (HKEY_LOCAL_MACHINE, _
                                           AUTH_STORE_PATH, _
                                           AUTH_STORE_KEY, _
                                           gszAuthStore)
            if (err.number) or (lReturn) Then 
                Error "OpenAuthorizationStore failed: Failed to query registry"
                Error err.number & " " & err.description
                lReturn = -1
            end if
        end if


        ' Verify is an XML file
        if (NO_ERROR = lReturn) Then
            if left(lcase(gszAuthStore),8) <> "msxml://" Then
                Error "This server is not using an XML based authorization store."
                Error "I'm assuming therefore that you already know what you are doing "
                Error "and I'm not going any further!"
                lReturn = -1
            end if
        end if

        ' Get the service application
        if (NO_ERROR = LReturn) Then

            Dbg DBG_STD, "OpenAuthorizationStore: GetStringValue"
            lReturn = oReg.GetStringValue (HKEY_LOCAL_MACHINE, _
                                           AUTH_STORE_PATH, _
                                           AUTH_STORE_SERVICE, _
                                           gszAuthStoreServiceApplication)
            if (err.number) or (lReturn) Then 
                Error "OpenAuthorizationStore failed: Failed to query registry"
                Error err.number & " " & err.description
                lReturn = -1
            end if
        end if

        if (NO_ERROR = lReturn) Then

            set oAuthStore = CreateObject("AzRoles.AzAuthorizationStore")
            if (err.number) or (oAuthStore is nothing) Then
                Error "Failed to create AzRoles.AzAuthorizationStore"
                Error err.number & " " & err.description
                lReturn = -1
            end if
        end if

        'Open the auth store
        ' http://msdn.microsoft.com/en-us/library/aa376359(VS.85).aspx  0=Update
        if (NO_ERROR = lReturn) Then
            oAuthStore.Initialize 0, gszAuthStore
            if (err.number) or (oAuthStore is nothing) Then
                Error "Failed to open authorization store"
                Error err.number & " " & err.description
                lReturn = -1
            end if
        end if

        set oReg = Nothing

        OpenAuthorizationStore = lReturn

    End Function

    ' ********************************************************************
    ' * AddRemoveAuthorizationStore: Adds or removes user/group
    ' ********************************************************************
    Function AddRemoveAuthorizationStore(oAuthStore, szRoleAssignment)


        Dim lReturn
        Dim oApplication            ' The Application Object
        Dim oRoleAssignment         ' For enumerating the role assignments in the policy store
        Dim szMemberName            ' What we are adding or removing

        On error resume next

        lReturn = NO_ERROR

        set oApplication = NOthing
        set oRoleAssignment = Nothing

        wscript.echo ""

        ' Open the application
        If (NO_ERROR = lReturn) Then
           Set oApplication = oAuthStore.OpenApplication(gszAuthStoreServiceApplication)
           if (err.number) or (oApplication is nothing) Then
               Error "Failed to open application in authorization store"
               Error err.number & " " & err.description
               lReturn = -1
           End If
        End If

        ' Open the role assignment
        If (NO_ERROR = lReturn) Then
           set oRoleAssignment = oApplication.OpenRoleAssignment(szRoleAssignment)
           if (err.number) or (oRoleAssignment is nothing) Then
               Error "Failed to open role assignment " & szRoleAssignment & " in authorization store"
               Error "Try using the /show option to display the contents of the store"
               Error "Is it possible you are using a custom store, or have provided an invalid "
               Error "parameter to /roleassign?"
               Error err.number & " " & err.description
               lReturn = -1
           End If
        End If


        ' Add or remove the user
        if (NO_ERROR = lReturn) Then

            szMemberName = ""
            if len(gszServerOpAddOrRemoveDomainName) Then
                szMemberName = szMemberName & gszServerOpAddOrRemoveDomainName & "\"
            end if
            szMemberName = szMemberName & gszServerOpAddOrRemoveUserName

            if (glServerOpAddRemoveUser = HVREMOTE_SERVEROP_ADDREMOVEUSER_ADD) Then
                wscript.echo "Adding " & szMemberName & " to AZMan role " & szRoleAssignment
                lReturn = oRoleAssignment.AddMemberName(szMemberName)
                select case err.number
                   case &H800700B7
                      wscript.echo "WARN: " & szMemberName & " is already in AZMan Role " & szRoleAssignment
                      err.clear
                      lReturn = NO_ERROR
                   case 0
                      lReturn = NO_ERROR
                   case else
                      ' The object model seems very fragile. Just in case, not quitting IF
                      ' hit a different error. JUst let the user know, but keep going
                      wscript.echo "ERROR: Could not add " & szMemberName & " to AZMan Role " & szRoleAssignment
                      wscript.echo err.description & " " & hex(err.number)
                      err.clear
                      lReturn = NO_ERROR
                end select
            else
                wscript.echo "Removing " & szMemberName & " from AZMan role " & szRoleAssignment
                lReturn = oRoleAssignment.DeleteMemberName(szMemberName)
                select case err.number
                   case &H80070490
                      wscript.echo "WARN: " & szMemberName & " is not in AZMan Role " & szRoleAssignment
                      err.clear
                      lReturn = NO_ERROR
                   case 0
                      lReturn = NO_ERROR
                   case else
                      ' The object model seems very fragile. Just in case, not quitting IF
                      ' hit a different error. JUst let the user know, but keep going
                      wscript.echo "ERROR: Could not remove " & szMemberName & " from AZMan Role " & szRoleAssignment
                      wscript.echo err.description & " " & hex(err.number)
                      err.clear
                      lReturn = NO_ERROR
                end select
            end if

            ' Submit anyway. As I say, I was struggling with fragility in the object model        
            oRoleAssignment.submit 0,0
            if (err.number) Then
                wscript.echo "ERROR after submit, but ignoring: " & err.description & " " & hex(err.number)
                err.clear
            end if

        End If


        set oApplication = NOthing
        set oRoleAssignment = Nothing

        AddRemoveAuthorizationStore=lReturn

    End Function




    ' ********************************************************************
    ' * ChangeFirewallPolicyForGroup: Enables or disables a firewall group
    ' ********************************************************************
    Function ChangeFirewallPolicyForGroup(szFirewallGroup, bDesiredEnabledValue)

        ' Based on sample from http://msdn.microsoft.com/en-us/library/aa364721(VS.85).aspx

        Dim lCurrentProfiles        ' Bitmask of the firewall profiles currently active.
        Dim arrInterfaces           ' Array of interfaces to which rule is excluded
        Dim lInterface              ' Looping through each of the excluded interfaces
        Dim oRule                   ' For enumerating through each of the rules
        Dim lNumChanged             ' Number of rules which are not in the desired enabled/disabled state
        Dim lReturn                 ' Function return value
        Dim oFWPolicy2              ' Object referencing the current firewall policy
        Dim lNumFound               ' Number of matching firewall rules

        lNumChanged = 0
        lNumFound = 0
        lReturn = NO_ERROR
        set oRule = Nothing
        set oFWPolicy2 = Nothing

        On error resume next

        if (not(gbIsFirewallRunning)) Then
            wscript.echo ""
            Error ""
            Error "Skipping. The firewall is not running or turned off"
            Error ""
            lReturn = -1
            Exit function
        end if



        ' Create the FwPolicy2 object.
        if (NO_ERROR = lReturn) Then
            Set oFWPolicy2 = CreateObject("HNetCfg.FwPolicy2")
            if (err.number) or (oFWPolicy2 is nothing) Then
                Error "Failed to create HNetCfg.FwPolicy2 object"
                Error err.description & " " & lReturn
                lReturn = -1
            end if
        end if

        
        ' Print all the rules.
        if (NO_ERROR = lReturn) Then
            For Each oRule In oFWPolicy2.Rules
                if lcase(oRule.Grouping) = LCase(szFirewallGroup) then

                    lNumFound = lNumFound + 1
                    if oRule.Enabled <> bDesiredEnabledValue Then
                        lNumChanged = lNumChanged + 1
                        oRule.Enabled = bDesiredEnabledValue
                        if err.number Then
                            Error "Failed to update firewall rule"
                            Error err.description & " " & err.number
                            Error "You must be running from an elevated command prompt"
                            wscript.quit
                        end if
                        if bDesiredEnabledValue then
                           wscript.echo "INFO: Enabled firewall rule " & oRule.Name
                        else
                            wscript.echo "INFO: Disabled firewall rule " & oRule.Name
                        end if
                    else
                        wscript.echo "WARN: " & oRule.Name & " firewall not updated"
                        glWarns = glWarns + 1
                        gszWarns = gszWarns & glWarns & ": Firewall Rule " & oRule.Name & " was not updated" & vbcrlf
                    end if

                end if
            Next

        end if

        if (NO_ERROR = lReturn) and (lNumFound = 0) Then
            Error "No firewall rules found in rule group " & szFirewallGroup
            lReturn = -1
        end if



        if lNumChanged Then wscript.echo "INFO: " & lNumChanged & " firewall rule(s) updated"

        set oRule = Nothing
        set oFWPolicy2 = Nothing

        ChangeFirewallPolicyForGroup = lReturn

    End Function ' ChangeFirewallPolicyForGroup


    ' ********************************************************************
    ' * ShowFirewallPolicyForGroup: Dumps out firewall group
    ' ********************************************************************
    Function ShowFirewallPolicyForGroup(szFirewallGroup, szFriendlyName, bCheckDesiredEnabledValue, bDesiredEnabledValue)

        Dim lCurrentProfiles        ' Bitmask of the firewall profiles currently active.
        Dim arrInterfaces           ' Array of interfaces to which rule is excluded
        Dim lInterface              ' Looping through each of the excluded interfaces
        Dim oRule                   ' For enumerating through each of the rules
        Dim lNotDesired             ' Number of rules which are not in the desired enabled/disabled state
        Dim lReturn                 ' Function return value
        Dim oFWPolicy2              ' Object referencing the current firewall policy


        lNotDesired = 0
        lReturn = NO_ERROR
        set oRule = Nothing
        set oFWPolicy2 = Nothing

        On error resume next

        wscript.echo " "
        wscript.echo "-------------------------------------------------------------------------------"
        wscript.echo "Firewall Settings for " & szFriendlyName
        wscript.echo "-------------------------------------------------------------------------------"
        wscript.echo " "

        if (not(gbIsFirewallRunning)) Then
            Error "Skipping. The firewall is not running or turned off"
            glWarns = glWarns + 1
            gszWarns = gszWarns & glWarns & ": Firewall not running (skipped " & szFriendlyName & ")" & vbcrlf
            Exit function
        end if


        ' Create the FwPolicy2 object.
        if (NO_ERROR = lReturn) Then
            Set oFWPolicy2 = CreateObject("HNetCfg.FwPolicy2")
            if (err.number) or (oFWPolicy2 is nothing) Then
                Error "Failed to create HNetCfg.FwPolicy2 object"
                Error err.description & " " & lReturn
                lReturn = -1
            end if
        end if

        ' Get and display the current profile type
        '// The returned 'CurrentProfiles' bitmask can have more than 1 bit set if multiple profiles 
        '//   are active or current at the same time
        if (NO_ERROR = lReturn) Then
            lCurrentProfiles = oFWPolicy2.CurrentProfileTypes
            if ( lCurrentProfiles AND NET_FW_PROFILE2_DOMAIN ) then  WScript.Echo("Domain Firewall Profile is active")
            if ( lCurrentProfiles AND NET_FW_PROFILE2_PRIVATE ) then WScript.Echo("Private Firewall Profile is active")
            if ( lCurrentProfiles AND NET_FW_PROFILE2_PUBLIC ) then  WScript.Echo("Public Firewall Profile is active")
            wscript.echo " "
        end if

        
        ' Print all the rules.
        if (NO_ERROR = lReturn) Then
            Dbg DBG_STD, "Rules:"

            For Each oRule In oFWPolicy2.Rules
                if lcase(oRule.Grouping) = LCase(szFirewallGroup) then
                    Dim szTemp
                    szTemp = "   "
                    if oRule.Enabled Then 
                       szTemp = szTemp & "Enabled:  "
                    else
                       szTemp = szTemp & "Disabled: "
                    end if
                    szTemp = szTemp & oRule.Name & " "
                    wscript.echo szTemp
                    Dbg DBG_STD,"        ----------------------------------------------"
                    Dbg DBG_STD,"  Description:        " & oRule.Description
                    Dbg DBG_STD,"  Application Name:   " & oRule.ApplicationName
                    Dbg DBG_STD,"  Service Name:       " & oRule.ServiceName
                    Select Case oRule.Protocol
                        Case NET_FW_IP_PROTOCOL_TCP    Dbg DBG_STD,"  IP Protocol:        TCP."
                        Case NET_FW_IP_PROTOCOL_UDP    Dbg DBG_STD,"  IP Protocol:        UDP."
                        Case NET_FW_IP_PROTOCOL_ICMPv4 Dbg DBG_STD,"  IP Protocol:        UDP."
                        Case NET_FW_IP_PROTOCOL_ICMPv6 Dbg DBG_STD,"  IP Protocol:        UDP."
                        Case Else                      Dbg DBG_STD,"  IP Protocol:        " & oRule.Protocol
                    End Select
                    if oRule.Protocol = NET_FW_IP_PROTOCOL_TCP or oRule.Protocol = NET_FW_IP_PROTOCOL_UDP then
                        Dbg DBG_STD,"  Local Ports:        " & oRule.LocalPorts
                        Dbg DBG_STD,"  Remote Ports:       " & oRule.RemotePorts
                        Dbg DBG_STD,"  LocalAddresses:     " & oRule.LocalAddresses
                        Dbg DBG_STD,"  RemoteAddresses:    " & oRule.RemoteAddresses
                    end if
                    if oRule.Protocol = NET_FW_IP_PROTOCOL_ICMPv4 or oRule.Protocol = NET_FW_IP_PROTOCOL_ICMPv6 then
                        Dbg DBG_STD,"  ICMP Type and Code:    " & oRule.IcmpTypesAndCodes
                    end if
                    Select Case oRule.Direction
                        Case NET_FW_RULE_DIR_IN  Dbg DBG_STD,"  Direction:          In"
                        Case NET_FW_RULE_DIR_OUT Dbg DBG_STD,"  Direction:          Out"
                    End Select
                    'WScript.Echo("        Enabled:            " & oRule.Enabled)
                    if bCheckDesiredEnabledValue Then
                        if oRule.enabled <> bDesiredEnabledValue Then
                    '        wscript.echo "**** This is not the desired value for the selected operation"
                            lNotDesired = lNotDesired + 1
                        end if
                    end if
                    Dbg DBG_STD,"  Edge:               " & oRule.EdgeTraversal
                    Select Case oRule.Action
                        Case NET_FW_ACTION_ALLOW  Dbg DBG_STD,"  Action:             Allow"
                        Case NET_FW_ACTION_BLOCk  Dbg DBG_STD,"  Action:             Block"
                    End Select
                    Dbg DBG_STD,"  Grouping:           " & oRule.Grouping
                    Dbg DBG_STD,"  Interface Types:    " & oRule.InterfaceTypes
                    arrInterfaces = oRule.Interfaces
                    if IsEmpty(arrInterfaces) then
                        Dbg DBG_STD,"There are no excluded interfaces"
                    else
                        Dbg DBG_STD,"Excluded interfaces: "
                        for lInterface = lBound(arrInterface) To UBound(arrInterface)
                            Dbg DBG_STD,"    " & arrInterfaces(lInterface)
                        Next
                    end if
                end if
            Next

        end if

        if (NO_ERROR = lReturn) And (bCheckDesiredEnabledValue) and (lNotDesired) Then
            wscript.echo ""
            wscript.echo "WARN: " & lNotDesired & " rules in the firewall group are not in the desired mode!"
            glWarns = glWarns + 1
            gszWarns = gszWarns & glWarns & ": Found some firewall rules in non-desired mode" & vbcrlf
         
        end if

        ShowFirewallPolicyForGroup = lReturn

        set oRule = Nothing
        set oFWPolicy2 = Nothing

    End Function ' ShowFirewallPolicyForGroup


    ' ********************************************************************
    ' * SetMMCFirewallRules: Updates or adds an MMC firewall exception in desired state
    ' ********************************************************************
    Function SetMMCFirewallRules(bDesiredEnabledState)

        ' UDP Example of what we want to create
        'DEBUG:   Rule Name:          MMC Elevated
        'DEBUG:    ----------------------------------------------
        'DEBUG:   Description:
        'DEBUG:   Application Name:   C:\Windows\System32\mmc.exe
        'DEBUG:   Service Name:
        'DEBUG:   IP Protocol:        UDP.
        'DEBUG:   Local Ports:        *
        'DEBUG:   Remote Ports:       *
        'DEBUG:   LocalAddresses:     *
        'DEBUG:   RemoteAddresses:    *
        'DEBUG:   Direction:          In
        'DEBUG:   Enabled:            False
        'DEBUG:   Edge:               False
        'DEBUG:   Action:             Allow
        'DEBUG:   Grouping:
        'DEBUG:   Edge:               False
        'DEBUG:   Interface Types:    All
        'DEBUG:   Interfaces:         All


        On error resume next

        Dim fwPolicy2                   ' Object model for firewall policy
        Dim RulesObject                 ' Rules in place for the firewall
        Dim lReturn                     ' Function return value
        Dim oShell                      ' WScript.shell object
        Dim szWinDir                    ' The windows directory
        Dim szMMCPath                   ' Full path to mmc.exe
        Dim oRule                       ' For enumerating the rules
        Dim bTCPRuleLooksValid          ' We do some very basic validation of the rule
        Dim bUDPRuleLooksValid          ' We do some very basic validation of the rule
        Dim oTCPRule                    ' The rule for protocol TCP
        Dim oUDPRule                    ' The rule for protocol UDP. We need TCP and UDP
        Dim CurrentProfiles             ' Current Profiles in place

        Set oTCPRule = Nothing
        set oUDPRule = Nothing
        set fwPolicy2 = Nothing
        set RulesObject = Nothing
        set oShell = Nothing
        set oRule = Nothing

        if (not(gbIsFirewallRunning)) Then
            wscript.echo ""
            Error ""
            Error "Skipping. The firewall is not running or turned off"
            Error ""
            lReturn = -1
            Exit function
        end if



        ' Need a shell object to get the windows directory
        if (NO_ERROR = lReturn) Then
            set oShell = WScript.CreateObject("WScript.Shell")
        end if

        ' Get the Windows directory from the environment
        if (NO_ERROR = lReturn) Then
            szWinDir = oShell.ExpandEnvironmentStrings("%windir%")
        end if

        ' Build the path to mmc.exe
        if (NO_ERROR = lReturn) Then szMMCPath = szWinDir & "\system32\mmc.exe"


        ' Create the FwPolicy2 object.
        if (NO_ERROR = lReturn) Then
            Set fwPolicy2 = CreateObject("HNetCfg.FwPolicy2")
        end if

        ' Get the bitmask of currently active profiles
        ' The returned 'CurrentProfiles' bitmask can have more than 1 bit set if multiple profiles 
        '   are active or current at the same time
        if (NO_ERROR = lReturn) Then
            CurrentProfiles = fwPolicy2.CurrentProfileTypes
        end if


        ' Get the Rules object
        if (NO_ERROR = lReturn) Then
            Set RulesObject = fwPolicy2.Rules
        end if

        ' Locate pre-existing rules if there are any
        if (NO_ERROR = lReturn) Then
               
            Dbg DBG_STD, "Searching for pre-existing rules"
            For Each oRule In Rulesobject

                ' Only interested in the rules which are for the MMC and relevant to the current profile
                if (oRule.Profiles And CurrentProfiles) and _
                   (lcase(oRule.ApplicationName) = lcase(szMMCPath)) Then

                    if oRule.Protocol = NET_FW_IP_PROTOCOL_TCP Then
                        set oTCPRule = oRule
                        Dbg DBG_STD, "Found TCP Rule"
                    end if

                    if oRule.Protocol = NET_FW_IP_PROTOCOL_UDP Then
                        set oUDPRule = oRule
                        Dbg DBG_STD,  "Found UDP Rule"
                    end if 
                end if
            next

            if (oTCPRule is nothing) Then wscript.echo "INFO: No TCP rule was found"
            if (oUDPRule is nothing) Then wscript.echo "INFO: No UDP rule was found"
        end if    




        ' Verify the rule looks like the one we really want (TCP)
        if (NO_ERROR = lReturn) and not(oTCPRule is nothing) Then
            bTCPRuleLooksValid = True
            if oTCPRule.LocalPorts <> "*" Then bTCPRuleLooksValid = False
            if oTCPRule.RemotePorts <> "*" Then bTCPRuleLooksValid = False
            if oTCPRule.LocalAddresses <> "*" THen bTCPRuleLooksValid = False
            if oTCPRule.RemoteAddresses <> "*" Then bTCPRuleLooksValid = False
            if oTCPRule.Direction <> NET_FW_RULE_DIR_IN Then bTCPRuleLooksValid = False
            if oTCPRule.Action<> NET_FW_ACTION_ALLOW Then bTCPRuleLooksValid = False
                

            if not(bTCPRuleLooksValid) Then
                Error "It looks like you have a custom rule already for MMC.exe (TCP). This"
                Error "script can only deal with simple settings for MMC firewall exceptions."
                Error "If you did not intend to have custom settings for MMC: "
                Error " - Start/Control Panel/Windows Firewall"
                Error " - Click Allow a program through Windows Firewall"
                Error " - Locate rule '" & oTCPRule.Name & "'"
                Error " - Select it and click Delete"
                Error "Then re-run this script to add or remove the MMC firewall exception"
                lReturn = -1
            else
                Dbg DBG_STD,  "INFO: TCP rule appears to be one we can handle"
            end if
        end if


        if (NO_ERROR = lReturn) and not(oUDPRule is nothing) Then
            bUDPRuleLooksValid = True
            if oUDPRule.LocalPorts <> "*" Then bUDPRuleLooksValid = False
            if oUDPRule.RemotePorts <> "*" Then bUDPRuleLooksValid = False
            if oUDPRule.LocalAddresses <> "*" THen bUDPRuleLooksValid = False
            if oUDPRule.RemoteAddresses <> "*" Then bUDPRuleLooksValid = False
            if oUDPRule.Direction <> NET_FW_RULE_DIR_IN Then bUDPRuleLooksValid = False
            if oUDPRule.Action<> NET_FW_ACTION_ALLOW Then bUDPRuleLooksValid = False
                

            if not(bUDPRuleLooksValid) Then
                Error "It looks like you have a custom rule already for MMC.exe (UDP). This"
                Error "script can only deal with simple settings for MMC firewall exceptions."
                Error "If you did not intend to have custom settings for MMC: "
                Error " - Start/Control Panel/Windows Firewall"
                Error " - Click Allow a program through Windows Firewall"
                Error " - Locate rule '" & oUDPRule.Name & "'"
                Error " - Select it and click Delete"
                Error "Then re-run this script to add or remove the MMC firewall exception"
                lReturn = -1
            else
                Dbg DBG_STD, "INFO: UDP rule appears to be one we can handle"
            end if
        end if
             
        ' Do we need to add a rule (TCP)? 
        if (NO_ERROR = lReturn) and (oTCPRule is nothing) and (bDesiredEnabledState = True) Then
            Dbg DBG_STD, "INFO: Adding TCP rule"
            set oTCPRule = CreateObject("HNetCfg.FWRule")
            if (oTCPRule is nothing) or (err.number) Then
                Error "Failed to instantiate new HNetCfg.FWRule"
                Error err.description & " " & err.number
                lReturn = -1
           else
                oTCPRule.Name = "Microsoft Management Console (HVRemote.wsf Created)"
                oTCPRule.ApplicationName = szMMCPath
                oTCPRule.Protocol = NET_FW_IP_PROTOCOL_TCP
                oTCPRule.Enabled = True
                oTCPRule.Direction = NET_FW_RULE_DIR_IN
                oTCPRule.Action = NET_FW_ACTION_ALLOW
                oTCPRule.Profiles = CurrentProfiles 
                Call RulesObject.Add(oTCPRule)
                if (err.number) Then
                    Error "Failed to add a TCP firewall Exception"
                    Error err.description & " " & err.number
                    lReturn = -1
                end if
            end if
            set oTCPRule = Nothing
        end if ' Adding TCP Rule

        ' Do we need to add a rule (UDP)? 
        if (NO_ERROR = lReturn) and (oUDPRule is nothing) and (bDesiredEnabledState = True) Then
            Dbg DBG_STD,  "INFO: Adding UDP rule"
            set oUDPRule = CreateObject("HNetCfg.FWRule")
            if (oUDPRule is nothing) or (err.number) Then
                Error "Failed to instantiate new HNetCfg.FWRule"
                Error err.description & " " & err.number
                lReturn = -1
           else
                oUDPRule.Name = "Microsoft Management Console (HVRemote.wsf Created)"
                oUDPRule.ApplicationName = szMMCPath
                oUDPRule.Protocol = NET_FW_IP_PROTOCOL_UDP
                oUDPRule.Enabled = True
                oUDPRule.Direction = NET_FW_RULE_DIR_IN
                oUDPRule.Action = NET_FW_ACTION_ALLOW
                oUDPRule.Profiles = CurrentProfiles 
                Call RulesObject.Add(oUDPRule)
                if (err.number) Then
                    Error "Failed to add a UDP firewall Exception"
                    Error err.description & " " & err.number
                    lReturn = -1
                end if
            end if
            set oUDPRule = Nothing
        end if ' Adding UDP Rule


        ' Do we need to update an existing rule (TCP)?
        if (NO_ERROR = lReturn) and not(oTCPRule is nothing) Then
            select case oTCPRule.Enabled
                case True
                    if bDesiredEnabledState = True Then
                        wscript.echo "WARN: TCP Rule is already enabled"
                    else
                        Dbg DBG_STD, "INFO: Disabling TCP Rule"
                        oTCPRule.Enabled = False
                    end if
                case False
                    if bDesiredEnabledState = False Then
                        wscript.echo "WARN: TCP Rule is already disabled"
                    else
                        Dbg DBG_STD,  "INFO: Enabling TCP Rule"
                        oTCPRule.Enabled = True
                    end if
            end select

            if (err.number) Then
                Error err.description & " " & hex(err.number)
                Error "You may not be running this script elevated"
                lReturn = -1
            end if

        end if


        ' Do we need to update an existing rule (UDP)?
        if (NO_ERROR = lReturn) and not(oUDPRule is nothing) Then
            select case oUDPRule.Enabled
                case True
                    if bDesiredEnabledState = True Then
                        wscript.echo "WARN: UDP Rule is already enabled"
                    else
                        Dbg DBG_STD,  "INFO: Disabling UDP Rule"
                       oUDPRule.Enabled = False
                    end if
                case False
                    if bDesiredEnabledState = False Then
                        wscript.echo "WARN: UDP Rule is already disabled"
                    else
                        Dbg DBG_STD,  "INFO: Enabling UDP Rule"
                        oUDPRule.Enabled = True
                    end if
            end select

            if (err.number) Then
                Error err.description & " " & hex(err.number)
                Error "You may not be running this script elevated"
                lReturn = -1
            end if


        end if

        if (NO_ERROR = lReturn) Then wscript.echo "INFO: MMC Firewall exception changes OK."


        Set oTCPRule = Nothing
        set oUDPRule = Nothing
        set fwPolicy2 = Nothing
        set RulesObject = Nothing
        set oShell = Nothing
        set oRule = Nothing
                

        SetMMCFirewallRules = lReturn


    End Function  ' SetMMCFirewallRules


    ' ********************************************************************
    ' * ShowMMCFirewallRules: Displays the current MMC exception rules (Client)
    ' ********************************************************************
    ' Based on http://msdn.microsoft.com/en-us/library/aa364724(VS.85).aspx
    Function ShowMMCFirewallRules()

        Dim fwPolicy2                   ' Object model for firewall policy
        Dim RulesObject                 ' Rules in place for the firewall
        Dim lReturn                     ' Function return value
        Dim oShell                      ' WScript.shell object
        Dim szWinDir                    ' The windows directory
        Dim szMMCPath                   ' Full path to mmc.exe
        Dim oRule                       ' For enumerating the rules
        Dim CurrentProfiles             ' Current Profiles in place
        Dim InterfaceArray              ' Array of interfaces the rule(s) applies to
        Dim lDisabledCount              ' Number of Disabled rules
        Dim lRulesFound                 ' Number of rules found

        On error resume next

        wscript.echo " "
        wscript.echo "-------------------------------------------------------------------------------"
        wscript.echo "Windows Firewall exception rule(s) for mmc.exe"
        wscript.echo "-------------------------------------------------------------------------------"
        wscript.echo " "

        set fwPolicy2 = Nothing
        set RulesObject = Nothing
        set oShell = Nothing
        set oRule = Nothing
        lDisabledCount = 0
        lRulesFound = 0


        if (not(gbIsFirewallRunning)) Then
            Error "Skipping. The firewall is not running or turned off"
            Exit function
        end if



        ' Need a shell object to get the windows directory
        if (NO_ERROR = lReturn) Then
            set oShell = WScript.CreateObject("WScript.Shell")
        end if

        ' Get the Windows directory from the environment
        if (NO_ERROR = lReturn) Then
            szWinDir = oShell.ExpandEnvironmentStrings("%windir%")
        end if

        ' Build the path to mmc.exe
        if (NO_ERROR = lReturn) Then szMMCPath = szWinDir & "\system32\mmc.exe"


        ' Create the FwPolicy2 object.
        if (NO_ERROR = lReturn) Then Set fwPolicy2 = CreateObject("HNetCfg.FwPolicy2")


        ' Get the bitmask of currently active profiles
        ' The returned 'CurrentProfiles' bitmask can have more than 1 bit set if multiple profiles 
        '   are active or current at the same time
        if (NO_ERROR = lReturn) Then
            CurrentProfiles = fwPolicy2.CurrentProfileTypes
        end if

        ' Display which profiles are currently active
        if (NO_ERROR = lReturn) Then            
            if ( CurrentProfiles AND NET_FW_PROFILE2_DOMAIN ) then  WScript.Echo("Domain Firewall Profile is active")
            if ( CurrentProfiles AND NET_FW_PROFILE2_PRIVATE ) then WScript.Echo("Private Firewall Profile is active")
            if ( CurrentProfiles AND NET_FW_PROFILE2_PUBLIC ) then  WScript.Echo("Public Firewall Profile is active")
            wscript.echo " "
        end if

        ' Get the Rules object
        if (NO_ERROR = lReturn) Then
            Set RulesObject = fwPolicy2.Rules
        end if

        ' Print all the rules in currently active firewall profiles.
        if (NO_ERROR = lReturn) Then
            Dbg DBG_STD, "Rules:"

            For Each oRule In Rulesobject

                ' Only interested in the rules which are for the MMC and relevant to the current profile
                if (oRule.Profiles And CurrentProfiles) and _
                   (lcase(oRule.ApplicationName) = lcase(szMMCPath)) Then

                    lRulesFound = lRulesFound + 1
                    if (oRule.Enabled = False) Then lDisabledCount = lDisabledCount + 1

                    Dim szTemp
                    szTemp = "   "
                    if oRule.Enabled Then 
                       szTemp = szTemp & "Enabled:  "
                    else
                       szTemp = szTemp & "Disabled: "
                    end if
                    szTemp = szTemp & oRule.Name & " "


                    Select Case oRule.Protocol
                       Case NET_FW_IP_PROTOCOL_TCP    szTemp = szTemp & "(TCP)"
                       Case NET_FW_IP_PROTOCOL_UDP    szTemp = szTemp & "(UDP)"
                       Case NET_FW_IP_PROTOCOL_ICMPv4 szTemp = szTemp & "(ICMPv4)"
                       Case NET_FW_IP_PROTOCOL_ICMPv6 szTemp = szTemp & "(ICMPv6)"
                       Case Else                      szTemp = szTemp & "(" & oRule.Protocol & ")"
                    End Select

                    wscript.echo szTemp
  
                    Dbg DBG_STD,"  Rule Name:          " & oRule.Name
                    Dbg DBG_STD,"   ----------------------------------------------"
                    'Dbg DBG_STD,"  Description:        " & oRule.Description
                    Dbg DBG_STD,"  Application Name:   " & oRule.ApplicationName
                    Dbg DBG_STD,"  Service Name:       " & oRule.ServiceName
                    Select Case oRule.Protocol
                        Case NET_FW_IP_PROTOCOL_TCP    Dbg DBG_STD,"  IP Protocol:        TCP."
                        Case NET_FW_IP_PROTOCOL_UDP    Dbg DBG_STD,"  IP Protocol:        UDP."
                        Case NET_FW_IP_PROTOCOL_ICMPv4 Dbg DBG_STD,"  IP Protocol:        UDP."
                        Case NET_FW_IP_PROTOCOL_ICMPv6 Dbg DBG_STD,"  IP Protocol:        UDP."
                        Case Else                      Dbg DBG_STD,"  IP Protocol:        " & oRule.Protocol
                    End Select
                    if oRule.Protocol = NET_FW_IP_PROTOCOL_TCP or oRule.Protocol = NET_FW_IP_PROTOCOL_UDP then
                        Dbg DBG_STD,"  Local Ports:        " & oRule.LocalPorts
                        Dbg DBG_STD,"  Remote Ports:       " & oRule.RemotePorts
                        Dbg DBG_STD,"  LocalAddresses:     " & oRule.LocalAddresses
                        Dbg DBG_STD,"  RemoteAddresses:    " & oRule.RemoteAddresses
                    end if
                    if oRule.Protocol = NET_FW_IP_PROTOCOL_ICMPv4 or oRule.Protocol = NET_FW_IP_PROTOCOL_ICMPv6 then
                        Dbg DBG_STD,"  ICMP Type and Code:    " & oRule.IcmpTypesAndCodes
                    end if
                    Select Case oRule.Direction
                        Case NET_FW_RULE_DIR_IN  Dbg DBG_STD,"  Direction:          In"
                        Case NET_FW_RULE_DIR_OUT Dbg DBG_STD,"  Direction:          Out"
                    End Select
                    Dbg DBG_STD,"  Enabled:            " & oRule.Enabled
                    Dbg DBG_STD,"  Edge:               " & oRule.EdgeTraversal
                    Select Case oRule.Action
                        Case NET_FW_ACTION_ALLOW  Dbg DBG_STD,"  Action:             Allow"
                        Case NET_FW_ACTION_BLOCk  Dbg DBG_STD,"  Action:             Block"
                    End Select
                    Dbg DBG_STD,"  Grouping:           " & oRule.Grouping
                    Dbg DBG_STD,"  Edge:               " & oRule.EdgeTraversal
                    Dbg DBG_STD,"  Interface Types:    " & oRule.InterfaceTypes
                    InterfaceArray = oRule.Interfaces
                    if IsEmpty(InterfaceArray) then
                        Dbg DBG_STD,"  Interfaces:         All"
                    else
                        LowerBound = LBound(InterfaceArray)
                        UpperBound = UBound(InterfaceArray)
                        Dbg DBG_STD,"  Interfaces:     "
                        for iterate = LowerBound To UpperBound
                           Dbg DBG_STD,"       " & InterfaceArray(iterate)
                        Next
                    end if
                end if


           Next

        End If

        if (lRulesFound = 0) Then
            wscript.echo " "
            wscript.echo "   WARN: No MMC exception rules were found. These rules are needed"
            wscript.echo "   for Hyper-V remote management. To add these rules, run: "
            wscript.echo " "
            wscript.echo "      hvremote.wsf /mode:client /mmc:enable"
            glWarns = glWarns + 1
            gszWarns = gszWarns & glWarns & ": Firewall exception rule for MMC is missing" & vbcrlf

        else
            if (lDisabledCount > 0) Then
                wscript.echo " "
                wscript.echo "   WARN: One or more disabled MMC exception rules were found. "
                wscript.echo "   These rules must be enabled for Hyper-V remote management. "
                wscript.echo "   To enable these rules, run: "
                wscript.echo " "
                wscript.echo "      hvremote.wsf /mode:client /mmc:enable"
                glWarns = glWarns + 1
                gszWarns = gszWarns & glWarns & ": Firewall MMC Exception rule(s) are disabled" & vbcrlf

            end if
        end if


        set fwPolicy2 = Nothing
        set RulesObject = Nothing
        set oShell = Nothing
        set oRule = Nothing


        ShowMMCFirewallRules = lReturn

    End Function ' ShowMMCFirewallRules     

    ' ********************************************************************
    ' * ParseCommandLine: Does exactly what it says on the tin....
    ' ********************************************************************

     Sub ParseCommandLine ()   ' Note - quits if fails.
        On error resume next

        Dim szTemp          ' Used for splitting certain parameters
        Dim i               ' Loop control


        ' Asking for usage?
        if WScript.Arguments.Named.Exists("?") Or _
           WScript.Arguments.Named.Exists("help") Then
            Usage ""
            wscript.quit
        end if

       ' Make sure all arguments are recognised
       if wscript.arguments.count > 0 Then
           For i=0 to wscript.arguments.count -1
               if (left(lcase(wscript.arguments(i)),2)  <> "/?"                    ) and _
                  (left(lcase(wscript.arguments(i)),3)  <> "/ns"                   ) and _
                  (left(lcase(wscript.arguments(i)),4)  <> "/add"                  ) and _
                  (left(lcase(wscript.arguments(i)),4)  <> "/mmc"                  ) and _ 
                  (left(lcase(wscript.arguments(i)),5)  <> "/show"                 ) and _
                  (left(lcase(wscript.arguments(i)),5)  <> "/mode"                 ) and _
                  (left(lcase(wscript.arguments(i)),5)  <> "/help"                 ) and _
                  (left(lcase(wscript.arguments(i)),6)  <> "/debug"                ) and _
                  (left(lcase(wscript.arguments(i)),6)  <> "/trace"                ) and _
                  (left(lcase(wscript.arguments(i)),6)  <> "/addop"                ) and _
                  (left(lcase(wscript.arguments(i)),7)  <> "/nodcom"               ) and _
                  (left(lcase(wscript.arguments(i)),7)  <> "/target"               ) and _
                  (left(lcase(wscript.arguments(i)),7)  <> "/remove"               ) and _
                  (left(lcase(wscript.arguments(i)),8)  <> "/noazman"              ) and _
                  (left(lcase(wscript.arguments(i)),9)  <> "/anondcom"             ) and _
                  (left(lcase(wscript.arguments(i)),11) <> "/roleassign"           ) and _
                  (left(lcase(wscript.arguments(i)),15) <> "/noversioncheck"       ) and _
                  (left(lcase(wscript.arguments(i)),16) <> "/firewallwmimgmt"      ) and _
                  (left(lcase(wscript.arguments(i)),19) <> "/firewallhypervmgmt"   ) and _
                  (left(lcase(wscript.arguments(i)),21) <> "/firewallhypervclient" ) Then
                      USAGE "Unrecognised parameter " & wscript.arguments(i)
                      wscript.quit
                end if
            next
        end if


        ' Must be client mode or server mode
        if not wscript.arguments.named.exists("mode") then
            ' Are we going to default to server if the role is installed and we're not asking for any other
            ' server operations?

            if (gbIsRoleInstalled) Then 
                glClientServerMode = HVREMOTE_MODE_SERVER
                wscript.echo "INFO: Assuming /mode:server as the role is installed"
            else
                glClientServerMode = HVREMOTE_MODE_CLIENT
                wscript.echo "INFO: Assuming /mode:client as the Hyper-V role is not installed"
                'Usage "ERROR: Mode parameter must be supplied {/mode:client|server}"
                'wscript.quit
            end if
        else
            select case wscript.arguments.named("mode") 
                case "client" glClientServerMode = HVREMOTE_MODE_CLIENT
                case "server" glClientServerMode = HVREMOTE_MODE_SERVER
                case else 
                     Usage "ERROR: Mode must be client or server (/mode:client|server)"
                     wscript.quit
            end select
        end if
 

        ' Client mode: Make sure no server only options have been supplied
        if (HVREMOTE_MODE_CLIENT = glClientServerMode) and _
           ((wscript.arguments.named.exists("ns")) or _
            (wscript.arguments.named.exists("noazman")) or _
            (wscript.arguments.named.exists("nodcom")) or _
            (wscript.arguments.named.exists("addop")) or _
            (wscript.arguments.named.exists("roleassign"))  or _
            (wscript.arguments.named.exists("FirewallWMIMgmt")) or _
            (wscript.arguments.named.exists("FirewallHyperVMgmt")) ) Then
            Usage "ERROR: One or more server options have been specified in client mode"
            wscript.quit
        end if

        ' Server mode: Make sure no client only options have been specified
        if (HVREMOTE_MODE_SERVER = glClientServerMode) and _
           ((wscript.arguments.named.exists("trace")) or _
            (wscript.arguments.named.exists("anonDCOM")) or _
            (wscript.arguments.named.exists("MMC")) Or _
            (wscript.arguments.named.exists("FirewallHyperVClient")) ) Then
            Usage "ERROR: One or more client options have been specified in server mode"
            wscript.quit
        end if



        ' Debug level
        if (wscript.arguments.named.exists("debug")) then
            select case wscript.arguments.named("debug")
                case ""           glDebugLevel = DBG_STD
                case "standard"   glDebugLevel = DBG_STD
                case "verbose"    glDebugLevel = DBG_EXTRA
                case else
                    Usage "ERROR:  /debug option incorrect. [standard|verbose]"
                    wscript.quit
            end select
        end if

        ' Version checking
        if (wscript.arguments.named.exists("noversioncheck")) Then gbVersionCheck = False
                  

        ' Client option
        ' Validate the /anonDCOM: parameter. 
        if (HVREMOTE_MODE_CLIENT = glClientServerMode) and _
           (WScript.Arguments.Named.Exists("anonDCOM")) Then 
             select case WScript.Arguments.Named("anonDCOM")
                 case "grant"   glClientOpAnonDCOMMode  = HVREMOTE_CLIENTOP_ANONDCOM_GRANT
                 case "revoke"  glClientOpAnonDCOMMode  = HVREMOTE_CLIENTOP_ANONDCOM_REVOKE
                 case else
                     Usage "ERROR: /anonDCOM option incorrect [revoke|grant]"
                     wscript.quit
             end select
        end if

        ' Client option
        ' Validate the /trace: parameter. 
        if (HVREMOTE_MODE_CLIENT = glClientServerMode) and _
           (WScript.Arguments.Named.Exists("trace")) Then 
             select case WScript.Arguments.Named("trace")
                 case "on"   glClientOpTracing  = HVREMOTE_CLIENTOP_TRACING_ON
                 case "off"  glClientOpTracing  = HVREMOTE_CLIENTOP_TRACING_OFF
                 case else
                     Usage "ERROR: /trace option incorrect [on|off]"
                     wscript.quit
             end select
        end if


        ' Server option. Add and Remove are mutually exclusive
        ' Parse the /remove:domain\user parameter
        if (HVREMOTE_MODE_SERVER = glClientServerMode) and _
           ((WScript.Arguments.Named.Exists("remove")) and _
            (WScript.Arguments.Named.Exists("add"))) Then 
            Usage "ERROR: Cannot specify /add and /remove!"
            wscript.quit
        end if

        ' Server option
        ' Parse the /add:domain\user parameter. 
        if WScript.Arguments.Named.Exists("add") Then 
            glServerOpAddRemoveUser = HVREMOTE_SERVEROP_ADDREMOVEUSER_ADD
            szTemp = WScript.Arguments.Named("add") 

            ' Domain must use domain\user format. Workgroup can do, but just user will do.
            if not gbComputerIsWorkgroup Then
                if (0=instr(szTemp,"\")) Then
                    Usage "ERROR: /add: Must be in format Domain\UserOrGroup"
                    wscript.quit
                end if
            end if

            if (0<>instr(szTemp,"\")) Then
                gszServerOpAddOrRemoveDomainName   = left(szTemp,instr(szTemp,"\")-1)
                gszServerOpAddOrRemoveUserName     = mid(szTemp,len(gszServerOpAddOrRemoveDomainName)+2)
            else
                gszServerOpAddOrRemoveDomainName   = ""
                gszServerOpAddOrRemoveUserName     = szTemp
            end if
        end if


        ' Server option
        ' Parse the /remove:domain\user parameter
        if WScript.Arguments.Named.Exists("remove") Then 
            glServerOpAddRemoveUser = HVREMOTE_SERVEROP_ADDREMOVEUSER_REMOVE
            szTemp = WScript.Arguments.Named("remove") 
            if not gbComputerIsWorkgroup Then
                if (0=instr(szTemp,"\")) Then
                    Usage "ERROR: /remove: Must be in format Domain\UserOrGroup"
                    wscript.quit
                end if
            end if
            if (0<>instr(szTemp,"\")) Then
                gszServerOpAddOrRemoveDomainName = left(szTemp,instr(szTemp,"\")-1)
                gszServerOpAddOrRemoveUserName   = mid(szTemp,len(gszServerOpAddOrRemoveDomainName)+2)
            else
                gszServerOpAddOrRemoveDomainName   = ""
                gszServerOpAddOrRemoveUserName     = szTemp
            end if
         
        end if
        
        ' Show option
        if WScript.Arguments.Named.Exists("show") Then
            if glServerOpAddRemoveUser <> HVREMOTE_SERVEROP_ADDREMOVEUSER_NONE Then
                Usage "ERROR: /show cannot be combined with /add or /remove"
                wscript.quit
            end if
            gbShowMode = True
        end if

        ' Target option to /show. Cannot be supplied if not in show mode
        if WScript.Arguments.Named.Exists("target") then
            if gbShowMode = False then
                Usage "ERROR: /target can only be used in conjunction with /show"
                wscript.quit
            else
                gszRemoteComputerName = WScript.Arguments.Named("target")
                if 0 = len(gszRemoteComputerName) Then
                    if (HVREMOTE_MODE_CLIENT = glClientServerMode) then
                        Usage "ERROR: /target must have a server name supplied"
                    else
                        Usage "ERROR: /target must have a client name supplied"
                    end if
                    wscript.quit
                end if
                gbTestConnectivity = True
            end if
        end if
       

        ' Server option
        ' Are we NOT updating or displaying DCOM Permissions? 
        ' Must be in /add or /remove mode, or show mode
        if WScript.Arguments.Named.Exists("nodcom") Then
            if (gbShowMode = False) And (glServerOpAddRemoveUser = HVREMOTE_SERVEROP_ADDREMOVEUSER_NONE) Then
                Usage "ERROR: Cannot use /nodcom unless in /add, /remove or /show modes"
                WScript.Quit
            end if
            glServerOpDCOMPermissions = HVREMOTE_SERVEROP_DCOMPERMISSIONS_OFF
        end if


        ' Server option
        ' Are we NOT updating or displaying AZMan settings?
        '  Must be in /add or /remove mode, or show mode
        if WScript.Arguments.Named.Exists("noazman") Then
            if (gbShowMode = False) And (glServerOpAddRemoveUser = HVREMOTE_SERVEROP_ADDREMOVEUSER_NONE) Then
                Usage "ERROR: Cannot use /noazman unless in /add, /remove or /show modes"
                WScript.Quit
            end if
            glServerOpAZManUpdate = HVREMOTE_SERVEROP_AZMANUPDATE_OFF
        end if


        ' Server option
        ' Are we limiting this to just one namespace?
        ' Must be in /add or /remove mode, or show mode
        if WScript.Arguments.Named.Exists("ns") Then
            if (gbShowMode = False) and (glServerOpAddRemoveUser = HVREMOTE_SERVEROP_ADDREMOVEUSER_NONE) Then
                Usage "ERROR: Cannot use /ns unless in /add, /remove or /show modes"
                WScript.Quit
            end if
    

            select case LCase(WScript.Arguments.Named("ns"))
                case "cimv2"           glServerOpNameSpacesToUse=NAMESPACE_CIMv2
                case "virtualization"  glServerOpNameSpacesToUse=NAMESPACE_VIRTUALIZATION
                case "none"            glServerOpNameSpacesToUse=0
                case else
                    Usage "ERROR: Unrecognized /ns option [none|cimv2|virtualization]"
                    wscript.quit
            end select
        end if

        ' Server Option
        ' Enabling/Disabling/No action on the Hyper-V firewall group (server rules)
        if WScript.Arguments.Named.Exists("FirewallHyperVMgmt") Then
            select case lcase(WScript.Arguments.Named("FirewallHyperVMgmt"))
                case "enable"     glServerOpFirewallHyperV = HVREMOTE_SERVEROP_FIREWALL_HYPERV_ALLOW
                case "disable"    glServerOpFirewallHyperV = HVREMOTE_SERVEROP_FIREWALL_HYPERV_DENY
                case "none"       glServerOpFirewallHyperV = HVREMOTE_SERVEROP_FIREWALL_HYPERV_NONE
                case else
                     Usage "ERROR: Unrecognised /FirewallHyperVMgmt option [enable|disable|none]"
                     wscript.quit
            end select
        end if

        ' Server Option
        ' Enabling/Disabling/No action on the WMI Remote Management (server rules)
        if WScript.Arguments.Named.Exists("FirewallWMIMgmt") Then
            select case lcase(WScript.Arguments.Named("FirewallWMIMgmt"))
                case "enable"     glServerOpFirewallWMIMgmt = HVREMOTE_SERVEROP_FIREWALL_WMIMGMT_ALLOW
                case "disable"    glServerOpFirewallWMIMgmt = HVREMOTE_SERVEROP_FIREWALL_WMIMGMT_DENY
                case "none"       glServerOpFirewallWMIMgmt = HVREMOTE_SERVEROP_FIREWALL_WMIMGMT_NONE
                case else
                     Usage "ERROR: Unrecognised /FirewallWMIMgmt option [enable|disable|none]"
                     wscript.quit
            end select
        end if

        ' Client option
        ' Enabling/Disabling/No action on the Hyper-V Management Client firewall
        if WScript.Arguments.Named.Exists("FirewallHyperVClient") Then
            select case lcase(WScript.Arguments.Named("FirewallHyperVClient"))
                case "enable"     glClientOpFirewallHyperVMgmtClient = HVREMOTE_CLIENTOP_FIREWALL_HYPERVMGMTCLIENT_ALLOW
                case "disable"    glClientOpFirewallHyperVMgmtClient = HVREMOTE_CLIENTOP_FIREWALL_HYPERVMGMTCLIENT_DENY
                case "none"       glClientOpFirewallHyperVMgmtClient = HVREMOTE_CLIENTOP_FIREWALL_HYPERVMGMTCLIENT_NONE
                case else
                     Usage "ERROR: Unrecognised /FirewallHyperVClient option [enable|disable|none]"
                     wscript.quit
            end select
        end if

        ' Client option
        ' Enabling/Disabling/No action on the MMC Exception in the Client firewall
        if WScript.Arguments.Named.Exists("mmc") Then
            select case lcase(WScript.Arguments.Named("mmc"))
                case "enable"     glClientOpFirewallMMCException = HVREMOTE_CLIENTOP_FIREWALL_MMCEXCEPTION_ALLOW 
                case "disable"    glClientOpFirewallMMCException = HVREMOTE_CLIENTOP_FIREWALL_MMCEXCEPTION_DENY
                case "none"       glClientOpFirewallMMCException = HVREMOTE_CLIENTOP_FIREWALL_MMCEXCEPTION_None
                case else
                     Usage "ERROR: Unrecognised /MMC option [enable|disable|none]"
                     wscript.quit
            end select
        end if

       
        ' Verify there is something to do (Server)
        if (glClientServerMode = HVREMOTE_MODE_SERVER) Then

           if (glServerOpAddRemoveUser = HVREMOTE_SERVEROP_ADDREMOVEUSER_NONE) and _
              (not gbShowMode) and _
              (glServerOpFirewallHyperV = HVREMOTE_SERVEROP_FIREWALL_HYPERV_NONE) and _
              (glServerOpFirewallWMIMgmt = HVREMOTE_SERVEROP_FIREWALL_WMIMGMT_NONE) Then
               Usage "ERROR: No server actions to perform"
               wscript.quit
           end if
        end if

        ' Verify there is something to do (Client)
        if (glClientServerMode = HVREMOTE_MODE_CLIENT) Then
           if (glClientOpFirewallHyperVMgmtClient = HVREMOTE_CLIENTOP_FIREWALL_HYPERVMGMTCLIENT_NONE) and _
              (not gbShowMode) and _
              (glClientOpFirewallMMCException     = HVREMOTE_CLIENTOP_FIREWALL_MMCEXCEPTION_NONE ) and _
              (glClientOpAnonDCOMMode             = HVREMOTE_CLIENTOP_ANONDCOM_NONE) and _
              (glClientOpTracing                  = HVREMOTE_CLIENTOP_TRACING_NONE) Then
               Usage "ERROR: No client actions to perform"
               wscript.quit
           end if
        end if

        ' Alternate role definition?
        if (WScript.Arguments.Named.Exists("roleassign")) and _
           (glClientServerMode = HVREMOTE_MODE_SERVER) Then
            gszRoleAssign = WScript.Arguments.Named("roleassign")
        end if


        Dbg DBG_EXTRA,  "   Client or Server Mode (1=Client)        " & glClientServerMode
        Dbg DBG_EXTRA,  "   Show mode?                              " & gbShowMode
        Dbg DBG_EXTRA,  "S: AZMan Update          (1=Yes)           " & glServerOpAZManUpdate                    
        Dbg DBG_EXTRA,  "S: Add or Remove User    (1=Add)           " & glServerOpAddRemoveUser
        Dbg DBG_EXTRA,  "S: Add/Remove User/Group                   " & gszServerOpAddOrRemoveUserName
        Dbg DBG_EXTRA,  "S: Add/Remove Domain                       " & gszServerOpAddOrRemoveDomainName
        Dbg DBG_EXTRA,  "S: Doing DCOM update or display?           " & glServerOpDCOMPermissions
        Dbg DBG_EXTRA,  "S: Domain AZMan update or display          " & glServerOpAZManUpdate
        Dbg DBG_EXTRA,  "S: Namespaces (1=Cimv2;2=Virtualizaiton)   " & glServerOpNameSpacesToUse
        Dbg DBG_EXTRA,  "S: Update FW WMI Remote Mgmt (1=Yes)       " & glServerOpFirewallWMIMgmt
        Dbg DBG_EXTRA,  "S: Update FW Hyper-V (1=Yes)               " & glServerOpFirewallHyperV
        Dbg DBG_EXTRA,  "S: Role Assignment                         " & gszRoleAssign
        Dbg DBG_EXTRA,  "C: Update FW Hyper-V Rmt Mgmt Clnt (1=yes) " & glClientOpFirewallHyperVMgmtClient
        Dbg DBG_EXTRA,  "C: Update FW MMC Exception (1=yes)         " & glClientOpFirewallMMCException
        Dbg DBG_EXTRA,  "C: Update Anon DCOM      (1=Grant)         " & glClientOpAnonDCOMMode  


    End Sub 'ParseCOmmandLine

    ' ********************************************************************
    ' * DoesAnonymousLogonHaveRemoteDCOM: Yes or No.
    ' ********************************************************************

    Function DoesAnonymousLogonHaveRemoteDCOM(oWin32SD)
        On error resume next

        Dim oACE
        DoesAnonymousLogonHaveRemoteDCOM = False

        for each oACE in oWin32SD.DACL
            if oACE.AceType = ADS_ACETYPE_ACCESS_ALLOWED and _
               oACE.Trustee.SIDString = SID_ANONYMOUS Then
                if oACE.AccessMask AND ACCESS_PERMISSION_REMOTE_ACCESS Then
                    DoesAnonymousLogonHaveRemoteDCOM  = True
                    exit function
                end if
            end if
        next

        set oACE = Nothing

    End Function ' DoesAnonymousLogonHaveRemoteDCOM


    ' ********************************************************************
    ' * AddAnonymousLogonToRemoteDCOM: Sets the SD
    ' ********************************************************************

    Function AddAnonymousLogonToRemoteDCOM(oConnection, oWin32SD)

        On error resume next

        Dim oACE           ' Looping through ACEs in the DACL
        Dim bPresent       ' Does ANONYMOUS LOGON appear in the DACL already?
        Dim arrDACL        ' ACEs in the DACL
        Dim lMaxACE        ' Number of ACEs in the DACL
        Dim oTrustee       ' Trustee for the anonymous logon account
        Dim oAnonLogonACE  ' Existing ACE for anonymous logon
        Dim oWin32SDHelper ' To convert Win32 SD to binary SD
        Dim aBinarySD      ' New SD in binary format
        Dim oReg           ' StdRegProv for writing the registry
        Dim lReturn        ' Function return value

        set oACE = nothing
        set oReg = Nothing
        bPresent = False
        set oTrustee = nothing
        set oAnonLogonACE = Nothing
        set oWin32SDHelper = Nothing
        lReturn = NO_ERROR

        Dbg DBG_STD, "AddAnonymousLogonToRemoteDCOM()"

        ' Look to see if the anonymous logon SID already exists
        if (NO_ERROR = lReturn) Then
            for each oACE in oWin32SD.DACL
                if oACE.AceType = ADS_ACETYPE_ACCESS_ALLOWED and _
                   (lcase(oACE.Trustee.SIDString) = lcase(SID_ANONYMOUS)) Then
                        bPresent = True
                        set oAnonLogonACE = oACE
                        Dbg DBG_STD, "AddAnonymousLogonToRemoteDCOM: An ACE exists"
                end if
            next
        End if

        ' We need a trustee object for the anonyomus logon account
        if (NO_ERROR = lReturn) Then
            Dbg DBG_STD, "AddAnonymousLogonToRemoteDCOM: Need to get Trustee for ANONYMOUS LOGON SID"
            lReturn = GetTrusteeForSID (SID_ANONYMOUS, oTrustee)
            if (lReturn) Then
                Error "FAILED: Could not get Trustee for " & SID_ANONYMOUS
                lReturn = -1
            end if
        end if

        ' Add the ACE if needed (ie it's not present in the DACL)
        if (NO_ERROR = lReturn) And not(bPresent) Then
            Dbg DBG_STD, "AddAnonymousLogonToRemoteDCOM: Need to add an ACE to the current DACL"
            ' Get the current DACL locally and resize it to add a new ACE to it. 
            lMaxACE = UBound(oWin32SD.DACL) + 1
            Dbg DBG_STD, "AddAnonymousLogonToRemoteDCOM: Resizing ACE Count to " & lMaxACE
            arrDACL = oWin32SD.DACL
            Redim Preserve arrDACL(lMaxACE)


            ' Create an object instance an populate it.
            set arrDACL(lMaxACE) = oConnection.Get("win32_ACE").SpawnInstance_
            arrDACL(lMaxACE).Properties_.Item("AccessMask") = ACCESS_PERMISSION_REMOTE_ACCESS or _
                                                              ACCESS_PERMISSION_OTHER_FLAG
            arrDACL(lMaxACE).Properties_.Item("AceFlags")   = 0
            arrDACL(lMaxACE).Properties_.Item("AceType")    = ADS_ACETYPE_ACCESS_ALLOWED
            arrDACL(lMaxACE).Properties_.Item("Trustee")    = oTrustee
 
            ' Set the DACL back in the security descriptor
            oWin32SD.Properties_.Item("DACL") = arrDACL

            if (0<>err.number) Then
                Error "AddAnonymousLogonToRemoteDCOM: Failed to Set DACL!!!" & err.description
                lReturn = -1
            end if

       end if

       ' Change the ACE if needed (ie it's already present)
       if (NO_ERROR = lReturn) and (bPresent) Then
            Dbg DBG_STD, "AddAnonymousLogonToRemoteDCOM: Updating accessmask"
            oAnonLogonACE.AccessMask = oAnonLogonACE.AccessMask Or ACCESS_PERMISSION_REMOTE_ACCESS
       end if

       ' Change the SD back to Binary form
        ' We use a helper function to convert security descriptor formats
        if (NO_ERROR = lReturn) Then
            Dbg DBG_STD, "AddAnonymousLogonToRemoteDCOM: Instantiate win32_securitydescriptorhelper"
            Set oWin32SDHelper = GetObject("winmgmts:root\cimv2:Win32_SecurityDescriptorHelper" )
            if (err.number) then
                Error "AddAnonymousLogonToRemoteDCOM() Failed to instantiate Win32_SecurityDescriptorHelper"
                Error "Error: " & err.description & " " & err.number
                lReturn = -1
            end if
        end if

        ' Convert the binary form to the Win32_SecurityDescriptor format
        if (NO_ERROR = lReturn) Then
            Dbg DBG_STD, "AddAnonymousLogonToRemoteDCOM() Convert to Binary SD "
            oWin32SDHelper.Win32SDToBinarySD oWin32SD, aBinarySD
            if (err.number) or (oWin32SD is nothing) then
                Error "AddAnonymousLogonToRemoteDCOM() Failed to Convert BinarySD to Win32SD"
                Error "Error: " & err.description & " " & err.number
                lReturn = -1
            end if
        end if


        ' Need StdRegProv to access the registry
        if (NO_ERROR = lReturn) Then
            Dbg DBG_STD, "AddAnonymousLogonToRemoteDCOM: Instantiate StdRegProv"
            set oReg=GetObject("winmgmts:{impersonationLevel=impersonate}!\\.\root\default:StdRegProv")
            if (err.number) or (oReg is Nothing) Then
                Error "AddAnonymousLogonToRemoteDCOM:  failed: Could not instantiate StdRegProv"
                Error err.number & " " & err.description
                lReturn = -1
            end if
        end if

        ' Get the Binary Security Descriptor
        if (NO_ERROR = lReturn) then
            Dbg DBG_STD, "AddAnonymousLogonToRemoteDCOM: SetBinaryValue"
            lReturn = oReg.SetBinaryValue (HKEY_LOCAL_MACHINE, _
                                           MACHINE_RESTRICTION_PATH, _
                                           MACHINE_ACCESS_RESTRICTION_KEY, _
                                           aBinarySD)
            if (err.number) or (lReturn) Then 
                Error "AddAnonymousLogonToRemoteDCOM failed: Failed to set registry"
                Error err.number & " " & err.description
                Error "Is it possible you are not running this script elevated?"
                lReturn = -1
            end if
        end if


        if (NO_ERROR = lReturn) Then
            wscript.echo "INFO Granted Remote DCOM Access to Anonymous Logon"
            wscript.echo "WARN: See documentation for security implications"
        end if


        set oACE = nothing
        set oReg = Nothing
        bPresent = False
        set oTrustee = nothing
        set oAnonLogonACE = Nothing
        set oWin32SDHelper = Nothing

        AddAnonymousLogonToRemoteDCOM = lReturn

    End Function ' AddAnonymousLogonToRemoteDCOM



    ' ********************************************************************
    ' * RemoveAnonymousLogonFromRemoteDCOM: Sets the SD
    ' ********************************************************************

    Function RemoveAnonymousLogonFromRemoteDCOM(oWin32SD)

        On error resume next

        Dim oACE           ' The allow ACE to update
        Dim oWin32SDHelper ' To convert Win32 SD to binary SD
        Dim aBinarySD      ' New SD in binary format
        Dim oReg           ' StdRegProv for writing the registry
        Dim lReturn        ' Function return value

        set oACE = nothing
        set oReg = Nothing
        set oWin32SDHelper = Nothing
        lReturn = NO_ERROR

        Dbg DBG_STD, "RemoveAnonymousLogonFromRemoteDCOM()"

        if (oWin32SD is Nothing) Then
            Error "RemoveAnonymousLogonFromRemoteDCOM - Passed a NULL Parameter!!"
            lReturn = -1
            wscript.quit
        end if


        ' Update the access mask in the ACE for anonymous logon SID
        if (NO_ERROR = lReturn) Then
            for each oACE in oWin32SD.DACL
                if oACE.AceType = ADS_ACETYPE_ACCESS_ALLOWED and _
                   (lcase(oACE.Trustee.SIDString) = lcase(SID_ANONYMOUS)) Then
                        oACE.AccessMask = oACE.AccessMask - ACCESS_PERMISSION_REMOTE_ACCESS
                        Dbg DBG_STD, "RemoveAnonymousLogonFromRemoteDCOM: Updated access mask to " & oACE.AccessMask
                end if
            next
        end if



       ' Change the SD back to Binary form
        ' We use a helper function to convert security descriptor formats
        if (NO_ERROR = lReturn) Then
            Dbg DBG_STD, "RemoveAnonymousLogonFromRemoteDCOM: Instantiate win32_securitydescriptorhelper"
            Set oWin32SDHelper = GetObject("winmgmts:root\cimv2:Win32_SecurityDescriptorHelper" )
            if (err.number) then
                Error "RemoveAnonymousLogonFromRemoteDCOM() Failed to instantiate Win32_SecurityDescriptorHelper"
                Error "Error: " & err.description & " " & err.number
                lReturn = -1
            end if
        end if

        ' Convert the binary form to the Win32_SecurityDescriptor format
        if (NO_ERROR = lReturn) Then
            Dbg DBG_STD, "RemoveAnonymousLogonFromRemoteDCOM() Convert to Binary SD "
            oWin32SDHelper.Win32SDToBinarySD oWin32SD, aBinarySD
            if (err.number) or (oWin32SD is nothing) then
                Error "RemoveAnonymousLogonFromRemoteDCOM() Failed to Convert BinarySD to Win32SD"
                Error "Error: " & err.description & " " & err.number
                lReturn = -1
            end if
        end if


        ' Need StdRegProv to access the registry
        if (NO_ERROR = lReturn) Then
            Dbg DBG_STD, "RemoveAnonymousLogonFromRemoteDCOM: Instantiate StdRegProv"
            set oReg=GetObject("winmgmts:{impersonationLevel=impersonate}!\\.\root\default:StdRegProv")
            if (err.number) or (oReg is Nothing) Then
                Error "ARemoveAnonymousLogonFromRemoteDCOM:  failed: Could not instantiate StdRegProv"
                Error err.number & " " & err.description
                lReturn = -1
            end if
        end if

        ' Get the Binary Security Descriptor
        if (NO_ERROR = lReturn) then
            Dbg DBG_STD, "RemoveAnonymousLogonFromRemoteDCOM: SetBinaryValue"
            lReturn = oReg.SetBinaryValue (HKEY_LOCAL_MACHINE, _
                                           MACHINE_RESTRICTION_PATH, _
                                           MACHINE_ACCESS_RESTRICTION_KEY, _
                                           aBinarySD)
            if (err.number) or (lReturn) Then 
                Error "RemoveAnonymousLogonFromRemoteDCOM failed: Failed to set registry"
                Error err.number & " " & err.description
                Error "Is it possible you are not running this script elevated?"
                lReturn = -1
            end if
        end if


        if (NO_ERROR = lReturn) Then
            wscript.echo "INFO Revoked Remote DCOM Access from Anonymous Logon"
        end if

        set oACE = nothing
        set oReg = Nothing
        set oWin32SDHelper = Nothing

        RemoveAnonymousLogonFromRemoteDCOM = lReturn

    End Function ' RemoveAnonymousLogonFromRemoteDCOM


    ' ********************************************************************
    ' * GetMachineRestrictionSDFromRegistry: Gets the current DCOM Access
    ' * Note: Called Server Side for Machine Launch Restriction and
    ' *       client side for machine access restriction
    ' ********************************************************************
    Function GetMachineRestrictionSDFromRegistry(szRegistryKey, ByRef oWin32SD)

        On error resume next

        Dim lReturn           ' Function Return Value
        Dim oReg              ' StdRegProv to query registry
        Dim aBinarySD         ' Binary Security Descriptor from registry
        Dim oWin32SDHelper    ' To convert binary SD to Win32 SD

        lReturn = NO_ERROR
        Set oWin32SDHelper = Nothing
        set oWin32SD = Nothing
        Dbg DBG_STD, "GetMachineRestrictionSDFromRegistry: Enter"

        ' Need StdRegProv to access the registry
        if (NO_ERROR = lReturn) Then
            Dbg DBG_STD, "GetMachineRestrictionSDFromRegistry: Instantiate StdRegProv"
            set oReg=GetObject("winmgmts:{impersonationLevel=impersonate}!\\.\root\default:StdRegProv")
            if (err.number) or (oReg is Nothing) Then
                Error "GetMachineRestrictionSDFromRegistry failed: Could not instantiate StdRegProv"
                Error err.number & " " & err.description
                lReturn = -1
            end if
        end if

        ' Get the Binary Security Descriptor
        if (NO_ERROR = lReturn) then
            Dbg DBG_STD, "GetMachineRestrictionSDFromRegistry: GetBinaryValue"
            lReturn = oReg.GetBinaryValue (HKEY_LOCAL_MACHINE, _
                                           MACHINE_RESTRICTION_PATH, _
                                           szRegistryKey, _
                                           aBinarySD)
            if (err.number) or (lReturn) Then 
                Error "GetMachineRestrictionSDFromRegistry failed: Failed to query registry"
                Error err.number & " " & err.description
                lReturn = -1
            end if
        end if


        ' We use a helper function to convert security descriptor formats
        if (NO_ERROR = lReturn) Then
            Dbg DBG_STD, "GetMachineRestrictionSDFromRegistry: Instantiate win32_securitydescriptorhelper"
            Set oWin32SDHelper = GetObject("winmgmts:root\cimv2:Win32_SecurityDescriptorHelper" )
            if (err.number) then
                Error "Failed to instantiate Win32_SecurityDescriptorHelper"
                Error "Error: " & err.description & " " & err.number
                lReturn = -1
            end if
        end if

        ' Convert the binary form to the Win32_SecurityDescriptor format
        if (NO_ERROR = lReturn) Then
            Dbg DBG_STD, "GetMachineRestrictionSDFromRegistry: Convert to Win32SD "
            oWin32SDHelper.BinarySDToWin32SD aBinarySD, oWin32SD
            if (err.number) or (oWin32SD is nothing) then
                Error "Failed to Convert BinarySD to Win32SD"
                Error "Error: " & err.description & " " & err.number
                lReturn = -1
            end if
        end if

        if (NO_ERROR = lReturn) Then
            Dbg DBG_STD, "GetMachineRestrictionSDFromRegistry: Old SD is " & oWin32SD.GetObjectText_
        end if

        Dbg DBG_STD, "GetMachineRestrictionSDFromRegistry: Exit RC=" & lReturn

        Set oWin32SDHelper = Nothing
        GetMachineRestrictionSDFromRegistry = lReturn

    End Function

    ' ********************************************************************
    ' * DisplayWin32SD: Displays a Win32_SecurityDescriptor object
    ' * Type=1 is a WMI Namespace
    ' * Type=2 is a Machine Restriction
    ' ********************************************************************
    Sub DisplayWin32SD(szDescription, lType, oWin32SD)

        Dim szOut      ' For building output string
        Dim oACE       ' Win32_ACE
        Dim lReturn    ' Function Return Value

        set oACE = Nothing

        On error resume next

        ' Note that this function completely ignores the SACL and deals only with the DACL.

        ' Note: For valid remote access to Hyper-V you need the following example settings:
        ' JHOWARD-W7\admin (S-1-5-21-1998084992-3850808323-2978472522-1000)
        '  Allow: EnabAct RemEnab  (33)
        '  Flags: InheritAce NoPropInheritAce ValidInheritFlags  (6)

        ' http://msdn.microsoft.com/en-us/library/aa394402(VS.85).aspx 
        ' class Win32_SecurityDescriptor : __SecurityDescriptor
        ' {
        '   uint32 ControlFlags;
        '   Win32_ACE DACL[];
        '   Win32_Trustee Group;
        '   Win32_Trustee Owner;
        '   Win32_ACE SACL[];
        ' };

 
        ' http://msdn.microsoft.com/en-us/library/aa394501(VS.85).aspx
        ' class Win32_Trustee : __Trustee
        ' {
        '   string Domain;
        '   string Name;
        '   uint8 SID[];
        '   uint32 SidLength;
        '   string SIDString;
        ' }; 

        ' http://msdn.microsoft.com/en-us/library/aa394063(VS.85).aspx
        ' class Win32_ACE : __ACE
        '{
        '  uint32 AccessMask;
        '  uint32 AceFlags;
        '  uint32 AceType;
        '  string GuidInheritedObjectType;
        '  string GuidObjectType;
        '  Win32_Trustee Trustee;
        '};

        if (oWin32SD is nothing) Then
            wscript.echo "!!! There is no security descriptor to display !!!"
            exit Sub
        end if

        wscript.echo " "
        wscript.echo "-------------------------------------------------------------------------------"
        select case lType
            case 1  
                 wscript.echo "DACL for WMI Namespace " & szDescription 
                 wscript.echo "Required for Hyper-V remote mangement: Allow, EnabAct, RemEnab, InheritAce"
                 wscript.echo "HVRemote also sets NoPropInheritAce and ValidInheritFlags"
            case 2  wscript.echo "DACL for " & szDescription
        end select
        wscript.echo "-------------------------------------------------------------------------------"
'        wscript.echo " "

        ' Loop through each DACL
        for each oACE in oWin32SD.DACL
            szOut = ""
            wscript.echo " "
            wscript.echo oACE.Trustee.Domain & "\" & oACE.Trustee.Name & "    (" & oACE.Trustee.SIDString & ")"

            ' http://msdn.microsoft.com/en-us/library/aa392712(VS.85).aspx
            if (ADS_ACETYPE_ACCESS_ALLOWED=oACE.AceType) Then szOut = szOut & "     Allow: "
            if (ADS_ACETYPE_ACCESS_DENIED =oACE.AceType) Then szOut = szOut & "     Deny:  "

            ' http://msdn.microsoft.com/en-us/library/aa392710(VS.85).aspx



            if (lType = 1) Then ' WMI Namespace
                if (oACE.AccessMask And WBEM_METHOD_EXECUTE)    Then szOut = SzOut & "Exec "
                if (oACE.AccessMask And WBEM_FULL_WRITE_REP)    Then szOut = SzOut & "FullWrt "
                if (oACE.AccessMask And WBEM_PARTIAL_WRITE_REP) Then szOut = SzOut & "PartWrt "
                if (oACE.AccessMask And WBEM_WRITE_PROVIDER)    Then szOut = SzOut & "ProvWrt "
                if (oACE.AccessMask And WBEM_ENABLE)            Then szOut = SzOut & "EnabAct "
                if (oACE.AccessMask And WBEM_REMOTE_ACCESS)     Then szOut = SzOut & "RemEnab "
                if (oACE.AccessMask And READ_CONTROL)           Then szOut = SzOut & "RdSec "
                if (oACE.AccessMask And WRITE_DAC)              Then szOut = SzOut & "EdSec "
            end if

            if (lType = 2) Then ' Machine Restriction
                if (oACE.AccessMask And ACCESS_PERMISSION_LOCAL_ACCESS)      Then szOut = SzOut & "LocalLaunch "
                if (oACE.AccessMask And ACCESS_PERMISSION_REMOTE_ACCESS)     Then szOut = SzOut & "RemoteLaunch "
                if (oACE.AccessMask And ACCESS_PERMISSION_LOCAL_ACTIVATION)  Then szOut = SzOut & "LocalActivation "
                if (oACE.AccessMask And ACCESS_PERMISSION_REMOTE_ACTIVATION) Then szOut = SzOut & "RemoteActivation "
 
            end if


            wscript.echo szOut & "(" & oACE.AccessMask & ")"

            if (lType=1) Then  ' WMI Namespace only
                'http://msdn.microsoft.com/en-us/library/aa392711(VS.85).aspx (which seems wrong)
                'Info taken from ObjectBrowser on ActiveDs Enumeration ADS_ACEFLAG_ENUM       
                szOut = "     Flags: "
                if (oACE.AceFlags And ADS_ACEFLAG_FAILED_ACCESS)            Then szOut = szOut & "FailedAccess "
                if (oACE.AceFlags And ADS_ACEFLAG_INHERIT_ACE)              Then szOut = szOut & "InheritAce "
                if (oACE.AceFlags And ADS_ACEFLAG_INHERIT_ONLY_ACE)         Then szOut = szOut & "InheritOnlyAce "
                if (oACE.AceFlags And ADS_ACEFLAG_INHERITED_ACE)            Then szOut = szOut & "InheritedAce "
                if (oACE.AceFlags And ADS_ACEFLAG_NO_PROPAGATE_INHERIT_ACE) Then szOut = szOut & "NoPropInheritAce "
                if (oACE.AceFlags And ADS_ACEFLAG_SUCCESSFUL_ACCESS)        Then szOut = szOut & "SuccessfulAccess "
                if (oACE.AceFlags And ADS_ACEFLAG_VALID_INHERIT_FLAGS)      Then szOut = szOut & "ValidInheritFlags "
              
                wscript.echo szOut & " (" & oACE.AceFlags & ")" 
            End if

            ' Useful for enhanced debugging, but turned off
            Dbg DBG_EXTRA, "DisplayWin32SD() Trustee in ACE is " & oACE.Trustee.GetObjectText_()

        next

        set oACE = Nothing
             
    End Sub ' DisplayWin32SD


    ' ********************************************************************
    ' * RemoveACEFromDACL: Rebuilds the DACL with an ACE of the trustee missing 
    ' * Returns ERROR_NOT_PRESENT if not found
    ' ********************************************************************
    Function RemoveACEFromDACL(ByRef oWin32SD, oConnection, oTrustee)

        Dim lNumValidAces    ' Number of ACEs which DON'T match Trustee
        Dim oACE             ' For enumerating the ACEs in the DACL
        Dim oACEs            ' Array of ACEs we build

        On error resume next
        Dbg DBG_STD, "RemoveACEFromDACL: SID=" & oTrustee.SIDString

        Set oACE = Nothing
        RemoveACEFromDACL = NO_ERROR


        ' HARD QUIT: Don't allow any of the well known built in SIDs
        if (lcase(oTrustee.SIDString) = lcase(SID_EVERYONE)) or _
           (lcase(oTrustee.SIDString) = lcase(SID_ANONYMOUS)) or _
           (lcase(oTrustee.SIDString) = lcase(SID_BUILTIN_ADMINISTRATORS)) or _
           (lcase(oTrustee.SIDString) = lcase(SID_DISTRIBUTED_COM_USERS)) Then
            Error "HARD BLOCK HERE. Not manipulating that group!!!"
            wscript.quit
        end if


        lNumValidAces = 0
        for each oACE in oWin32SD.DACL
            if oACE.Trustee.SIDString <> oTrustee.SIDString Then lNumValidAces = lNumValidAces + 1
        next

        Dbg DBG_STD, "RemoveACEFromDACL: " & lNumValidAces & " of " & ubound(oWin32SD.DACL)+1

        if lNumValidAces = ubound(oWin32SD.DACL)+1 then
            Error "WARN: User is not currently in the DACL for the namespace"
            RemoveACEFromDACL = ERROR_NOT_PRESENT
            exit function
        end if

        Redim oACES(lNumValidACEs-1)
        lNumValidACEs = 0
        for each oACE in oWin32SD.DACL
            if oACE.Trustee.SIDString <> oTrustee.SIDString Then
                set oACEs(lNumValidACEs) = oConnection.Get("Win32_ACE").SpawnInstance_
                oACEs(lNumValidACEs).AccessMask = oACE.AccessMask
                oACEs(lNumValidACEs).ACEFlags = oACE.ACEFlags
                oACEs(lNumValidACEs).ACEType = oACE.ACEType
                oACEs(lNumValidACEs).Trustee = oACE.Trustee
                lNumValidACEs = lNumValidACEs + 1
            end if
        next

       
        ' Update the DACL
        oWin32SD.Properties_.Item("DACL") = oACEs
        Dbg DBG_STD, "RemoveACEFromDACL: After removing ACE " & oWin32SD.GetObjectText_
        Dbg DBG_STD, "RemoveACEFromDACL: RC=" & err.number

        Set oACE = Nothing

    End Function ' RemoveACEFromDACL

    ' ********************************************************************
    ' * AddACEToDACL: Rebuilds the DACL with an ACE of the trustee missing 
    ' * Returns ERROR_ALREADY_PRESENT if it's already in there
    ' ********************************************************************
    Function AddACEToDACL(ByRef oWin32SD, oConnection, oTrustee)

        Dim lMaxACE     ' Number of ACEs in the DACL
        Dim arrDACL     ' Array of DACLs to set in the win32_SecurityDescriptor
        Dim i           ' Lopp control variable

        On error resume next

        Dbg DBG_STD, "AddAceToDACL: SID=" & oTrustee.SIDString


        ' HARD QUIT: Don't allow any of the well known built in SIDs
        if (lcase(oTrustee.SIDString) = lcase(SID_EVERYONE)) or _
           (lcase(oTrustee.SIDString) = lcase(SID_ANONYMOUS)) or _
           (lcase(oTrustee.SIDString) = lcase(SID_BUILTIN_ADMINISTRATORS)) or _
           (lcase(oTrustee.SIDString) = lcase(SID_DISTRIBUTED_COM_USERS)) Then
            Error "HARD BLOCK HERE. Not manipulating that group!!!"
            wscript.quit
        end if


        ' Does an entry already exist (BUG BUG - Should check for deny's explicitly)
        for i = lbound(oWin32SD.DACL) to ubound(oWin32SD.DACL)
            if lcase(oTrustee.SIDString) = lcase(oWin32SD.DACL(i).Trustee.SIDString) Then
                Dbg DBG_STD, "AddAceToDACL() - ACE already exists, not adding"
                wscript.echo "WARN: An ACL already exists for this user. Not adding another one!"
                AddAceToDACL = ERROR_ALREADY_PRESENT
                exit function
            end if
        next


        ' Get the current DACL locally and resize it to add a new ACE to it. 
        lMaxACE = UBound(oWin32SD.DACL) + 1
        Dbg DBG_STD, "AddAceToDACL: Resizing ACE Count to " & lMaxACE
        arrDACL = oWin32SD.DACL
        Redim Preserve arrDACL(lMaxACE)


        ' Create an object instance an populate it.
        set arrDACL(lMaxACE) = oConnection.Get("win32_ACE").SpawnInstance_
        arrDACL(lMaxACE).Properties_.Item("AccessMask") = WBEM_ENABLE + WBEM_REMOTE_ACCESS
        arrDACL(lMaxACE).Properties_.Item("AceFlags")   = ADS_ACEFLAG_INHERIT_ACE + _ 
                                                          ADS_ACEFLAG_NO_PROPAGATE_INHERIT_ACE
        arrDACL(lMaxACE).Properties_.Item("AceType")    = ADS_ACETYPE_ACCESS_ALLOWED
        arrDACL(lMaxACE).Properties_.Item("Trustee")    = oTrustee

        ' Set the DACL back in the security descriptor
        oWin32SD.Properties_.Item("DACL") = arrDACL

        if (0<>err.number) Then
            Error "AddACEToDACL: Failed to Set DACL!!!" & err.description
            wscript.quit
        else
            Dbg DBG_STD, "AddAceToDACL: RC=0"
        end if

        AddACEToDACL = NO_ERROR 

    End Function ' AddACEToDACL


    ' ********************************************************************
    ' * GetWin32SD: Gets a Win32_SecurityDescriptor object
    ' ********************************************************************
    Function GetWin32SD(oConnection, ByRef oWin32SD)

        Dim oSystemSecurity    ' Object for __SystemSecurity
        Dim lReturn            ' Function return value
        Dim outParams          ' output Parameters from GetSD WMI Call
        Dim oWin32SDHelper     ' Helper utility for converting binary SDDL

        On error resume next

        lReturn = NO_ERROR
        set oWin32SD = nothing
        set oSystemSecurity = Nothing
        set outParams = Nothing
        set oWin32SDHelper = Nothing

        if (NO_ERROR = lReturn) Then               
            Dbg DBG_STD, "GetWin32SD(): Get __SystemSecurity"
            Set oSystemSecurity = oConnection.Get("__SystemSecurity=@")
            if (err.number) then
                Error "Failed to get system security for namespace"
                Error "Error: " & err.description & " " & err.number
                lReturn = -1
            end if
        end if

        ' BUG BUG - Fixed in 0.6. 518091. GetSecurityDescriptor has a problem when there unknown SIDs
        ' You can get this by having a domain joined box, adding a domain user, then moving the
        ' box to a workgroup. 

        'if (NO_ERROR = lReturn) Then
        '    set outParams = oSystemSecurity.ExecMethod_("GetSecurityDescriptor")
        '    if (outParams is nothing) or (err.number) Then
        '        lReturn = -1
        '        Error "Failed to call GetSecurityDescriptor" 
        '        if not(outParams is nothing) then Dbg DBG_STD, "GetSeurityDesecriptor ReturnValue=" & outParams.ReturnValue 
        '    else
        '        set oWin32SD = outParams.Descriptor
        '        Dbg DBG_STD, "Current SecurityDescriptor Details:" & oWin32SD.GetObjectText_
        '    end if
        'end if

        ' Fixed Code for workaround. Use GetSD then convert binary SDDL
        if (NO_ERROR = lReturn) Then
            set outParams = oSystemSecurity.ExecMethod_("GetSD")
            if (outParams is nothing) or (err.number) Then
                lReturn = -1
                Error "Failed to call GetSD" 
                if not(outParams is nothing) then Dbg DBG_STD, "GetSD ReturnValue=" & outParams.ReturnValue 
            else
                set oWin32SD = outParams.Descriptor
                Dbg DBG_STD, "Current SD (Binary Details:" & outParams.GetObjectText_
            end if
        end if

        ' Instantiate a Win32_SecurityDescriptorHelper object
        if (NO_ERROR = lReturn) Then
            err.clear
            set oWin32SDHelper = GetObject("winmgmts:root\cimv2:Win32_SecurityDescriptorHelper")
            if (err.number) or (oWin32SDHelper is nothing) then
                Error "Failed to instantiate Win32_SecurityDescriptorHelper"
                Error "Error: " & err.description & " " & err.number
                lReturn = -1
            end if
        end if

        ' Do the conversion
        if (NO_ERROR = lReturn) Then
            set oWin32SD = Nothing
            err.clear
            oWin32SDHelper.BinarySDToWin32SD outparams.SD, oWin32SD
            if (err.number) or (oWin32SDHelper is nothing) then
                Error "Failed to convert binary SDDL using Win32_SecurityDescriptorHelper"
                Error "Error: " & err.description & " " & err.number
                lReturn = -1
            else
                Dbg DBG_STD, "Current Security Descriptor (converted):" & oWin32SD.GetObjectText_
            end if
        end if

 

        Dbg DBG_STD, "GetWin32SD(): Exit RC=" & lReturn

        GetWin32SD = lReturn
        set oSystemSecurity = Nothing
        set outParams = Nothing
        set oWin32SDHelper = Nothing

    End Function ' GetWin32SD

    ' ********************************************************************
    ' * SetWin32SD: Sets a Win32_SecurityDescriptor object for a namespace
    ' ********************************************************************
    Function SetWin32SD(szNameSpace, oWin32SD, oConnection)

        Dim lReturn            ' Function return value
        Dim oSystemSecurity    ' Object for __SystemSecurity
        Dim inParams           ' Input parameters to SetSecurityDescriptor
        Dim outParams          ' Output parameters from SetSecurityDescriptor

        On error resume next


        set oSystemSecurity = Nothing
        set inParams = Nothing
        set outParams = Nothing
        lReturn = NO_ERROR

        if (NO_ERROR = lReturn) Then               
            Dbg DBG_STD, "SetWin32SD(): Get __SystemSecurity"
            Set oSystemSecurity = oConnection.Get("__SystemSecurity=@")
            if (err.number) then
                Error "Failed to get system security for namespace " & szNameSpace
                Error "Error: " & err.description & " " & err.number
                lReturn = -1
            end if
        end if

        if (NO_ERROR = lReturn) Then
            Dbg DBG_STD, "SetWin32SD(): Spawning inParams"
            set inParams = oSystemSecurity.methods_("SetSecurityDescriptor").inParameters.SpawnInstance_
            if (err.number) or (inParams is nothing) Then
                Error "Failed to spawn inParams for SetSecurityDescriptor"
                Error "Error: " & err.description & " " & err.number
                lReturn = -1
            end if
        end if
 
        if (NO_ERROR = lReturn) Then
            Dbg DBG_STD, "SetWin32SD(): Setting inParams for call"
            inParams.Descriptor = oWin32SD
            inParams.Descriptor.ControlFlags = SE_DACL_PRESENT
            if (err.number) Then
                Error "Failed to set inParams for SetSecurityDescriptor"
                Error "Error: " & err.description & " " & err.number
                lReturn = -1
            end if
        end if

        if (NO_ERROR = lReturn) Then
            Dbg DBG_STD, "SetWin32SD(): Calling SetSecurityDescriptor"
            Set outParams = oSystemSecurity.ExecMethod_("SetSecurityDescriptor", inParams)
            if (err.number) or (outParams is nothing) Then
                Error "Failed to call SetSecurityDescriptor"
                Error "Error: " & err.description & " " & err.number
                lReturn = -1
            end if

        end if

        ' Special case way of validating return code from method invocation 
        if (NO_ERROR = lReturn) Then
            lReturn = outParams.ReturnValue
            if (NO_ERROR <> lReturn) Then
                Error "Call to SetSecurityDescriptor failed"
                Error "Error RC=" & lReturn
            end if
        end if
          
        Dbg DBG_STD, "SetWin32SD(): Exit " & lReturn
        Dbg DBG_EXTRA, "SetWin32SD: New SD " & oWin32SD.GetObjectText_
        if (NO_ERROR = lReturn) Then wscript.echo "OK: Security update applied to " & szNameSpace & " namespace"

        set oSystemSecurity = Nothing
        set inParams = Nothing
        set outParams = Nothing


        SetWin32SD = lReturn

    End Function 'SetSD


    ' ********************************************************************
    ' * GetTrustee: Gets a Trustee for a user or group plus domain
    ' ********************************************************************
    Function GetTrustee(szInDomain, szUserOrGroup, ByRef oTrustee)

        Dim lReturn           ' Function return value tracking
        Dim oAccount          ' Either user or group
        Dim oAccountSID       ' SID object for the account (user or group) we are looking for
        Dim szDomain

        On error resume next    
        szDomain = szInDomain
        set oAccount = Nothing
        set oAccountSID = Nothing
        lReturn = NO_ERROR

        ' If we're in a workgroup and no domain was supplied by user, use the local computer name for the domain
        if 0=len(szDomain) Then
            if gbComputerIsWorkgroup Then szDomain = gszLocalComputerName                     
        end if

        Dbg DBG_STD, "GetTrustee(" & szDomain& "," & szUserOrGroup & ")"

        if (NO_ERROR = lReturn) Then
            Set oTrustee = GetObject("winmgmts:{impersonationlevel=impersonate}!//./root/cimv2:Win32_Trustee").Spawninstance_
            if (oTrustee is nothing) or (err.number) Then
                lReturn = -1        
                Error "Failed to get Win32_Trustee"         
                Error "Error: " & err.description & " " & err.number 
            else
                Dbg DBG_STD, "GetTrustee(): OK Win32_Trustee"
            end if
        end if
        
        ' Try group and if that fails, try a user
        if (NO_ERROR = lReturn) Then

            ' Group
            Set oAccount = GetObject("winmgmts:{impersonationlevel=impersonate}!//./root/cimv2:Win32_Group.Name='" & szUserOrGroup & "',Domain='" & szDomain &"'")

            if (ERROR_OBJECT_NOT_FOUND = err.number) Then 
                ' Group wasn't found
                Dbg DBG_STD, "GetTrustee(): Group not found, will try user"
                Err.clear

                ' Try Account
                Set oAccount = GetObject("winmgmts:{impersonationlevel=impersonate}!//./root/cimv2:Win32_Account.Name='" & szUserOrGroup & "',Domain='" & szDomain &"'") 

                ' Can't do anything if group AND user not found
                if (ERROR_OBJECT_NOT_FOUND = err.number) Then
                    Error "GetTrustee Failed: " & szDomain & "\" & szUserOrGroup & " not found"
                    Error "If " & szDomain & " is a domain, you need to be connected to the domain for this to work"
                    lReturn = -1
                else
                    ' Some other catastrophic error occurred?
                    if (err.number) or (oAccount is nothing) Then
                        lReturn = -1
                        Error "Failure finding trustee " & err.description & " " & err.number
                    else
                        Dbg DBG_STD, "GetTrustee(): Found user or group OK"
                    end if
                end if
            else
                ' Some unexpected error getting the account by group?
                if (err.number) or (oAccount is nothing) Then
                    lReturn = -1 
                    Error "Failure finding trustee " & err.description & "  " & err.number 
                end if
            end if
        end if    


        ' Get the SID for the user or group we located above.        
        if (NO_ERROR = lReturn) Then
            set oAccountSID = GetObject("winmgmts:{impersonationlevel=impersonate}!//./root/cimv2:Win32_SID.SID='" & oAccount.SID &"'")
            if (err.number) or (oAccountSID is Nothing) Then
                Error "Failure to get Account SID" 
                Error err.description & " " & err.number
            end if
        end if

        ' Create the Trustee Object
        if (NO_ERROR = lReturn) Then
            oTrustee.Name   = szUserOrGroup
            oTrustee.Domain = szDomain
            oTrustee.Properties_.Item("SID") = oAccountSid.BinaryRepresentation
            oTrustee.SIDString = oAccount.SID
            oTrustee.SIDLength = UBound(oAccountSID.BinaryRepresentation) + 1
            Dbg DBG_STD, "Trustee Instance We Built: " & oTrustee.GetObjectText_()
        end if

        set oAccount = Nothing
        set oAccountSID = Nothing
        GetTrustee = lReturn
        Dbg DBG_STD, "GetTrustee(): Exit RC=" & lReturn


   
    End Function ' GetTrustee


    ' ********************************************************************
    ' * GetTrusteeForSID: Gets a Trustee for a specified SID
    ' ********************************************************************

    Function GetTrusteeForSID(szSID, ByRef oTrustee)
        Dim lReturn           ' Function return value tracking
        Dim oAccountSID       ' SID object for the account we are looking for
        On error resume next    

        lReturn = NO_ERROR
        set oAccountSID = Nothing

        On error resume next

        Dbg DBG_STD, "GetTrusteeForSID(" & szSID &  ")"

        if (NO_ERROR = lReturn) Then
            Set oTrustee = GetObject("winmgmts:{impersonationlevel=impersonate}!//./root/cimv2:Win32_Trustee").Spawninstance_
            if (oTrustee is nothing) or (err.number) Then
                lReturn = -1        
                Error "Failed to get Win32_Trustee"         
                Error "Error: " & err.description & " " & err.number 
            else
                Dbg DBG_STD, "DEBUG: GetTrusteeForSID(): OK Win32_Trustee"
            end if
        end if

        ' Get the Win32_SID object
        if (NO_ERROR = lReturn) Then
            set oAccountSID = GetObject("winmgmts:{impersonationlevel=impersonate}!//./root/cimv2:Win32_SID.SID='" & szSID &"'")
            if (err.number) or (oAccountSID is Nothing) Then
                Error "Failure to get Account SID" 
                Error err.description & " " & err.number
            end if
        end if

        
        ' Copy the stuff across
        if (NO_ERROR = lReturn) Then
            oTrustee.Name   = oAccountSID.AccountName
            oTrustee.Domain = oAccountSID.ReferencedDomainName
            oTrustee.SID = oAccountSID.BinaryRepresentation
            oTrustee.SIDString = oAccountSID.SID
            oTrustee.SIDLength = UBound(oAccountSID.BinaryRepresentation) + 1
            Dbg DBG_STD, "GetTrusteeForSID: Trustee Instance We Built: " & oTrustee.GetObjectText_()
        end if

        set oAccountSID = Nothing
        GetTrusteeForSID = lReturn
        Dbg DBG_STD, "GetTrusteeForSID(): Exit RC=" & lReturn

    End Function ' GetTrusteeForSID


    ' ********************************************************************
    ' * Title: Displays title when invoked
    ' ********************************************************************
    Sub Title()

        On error resume next

                     '12345678901234567890123456789012345678901234567890123456789012345678901234567890
        wscript.echo " "
        wscript.echo "Hyper-V Remote Management Configuration & Checkup Utility"    
        wscript.echo "John Howard, Hyper-V Team, Microsoft Corporation."
        wscript.echo "http://blogs.technet.com/jhoward"
        wscript.echo "Version " & VERSION & " " & RELEASE_DATE
        wscript.echo "  "


    End Sub ' Title


    ' ********************************************************************
    ' * Usage: Displays Usage Help
    ' ********************************************************************
    Function Usage(szError)

        On error resume next

        wscript.echo "                                          "
        wscript.echo "Usage: cscript HVRemote /mode:server|client Operations [Options]"
        wscript.echo "" 
        wscript.echo "Server Mode "
        wscript.echo "    Operations: [/show [/target:clientname]   |"
        wscript.echo "                 /add:domain\userorgroup      | "
        wscript.echo "                 /remove:domain\userorgroup]"
        wscript.echo "                [/firewallwmimgmt:enable | disable | None]"
        wscript.echo "                [/firewallhypervmgmt:enable | disable | None]"
        wscript.echo " "
        wscript.echo "    Options:    [/ns:none | cimv2 | virtualization]"
        wscript.echo "                [/noazman]"
        wscript.echo "                [/nodcom]"
        wscript.echo "                [/roleassign:<Role Assignment in AZMan store>]"
        wscript.echo " "
        wscript.echo "Client Mode "
        wscript.echo "    Operations: [/show [/target:servername] | " 
        wscript.echo "                 /anondcom:grant|revoke | "
        wscript.echo "                 /firewallhypervclient:enable | disable | none]"
        wscript.echo "                 /mmc:enable | disable | none]"
        wscript.echo "                 /trace:on | off]"
        wscript.echo " "
        wscript.echo "All Modes "
        wscript.echo "    Options:    [/debug:standard|verbose]"
        wscript.echo "                [/noversioncheck]"
        wscript.echo "               "
        wscript.echo "See online documentation for more information"
        wscript.echo " - " & gszLV_URL
        wscript.echo " - " & gszLV_BlogURL
        wscript.echo ""
 
         if Len(szError) Then
            Error szError
            wscript.quit -1
        end if

    End Function ' Usage


    ' ********************************************************************
    ' * GetGroupNameForSID : Gets *LOCALISED* group name for a SID
    ' ********************************************************************
    Function GetGroupNameForSID (szSID, ByRef szGroupName)

        Dim colAccounts       ' Collection of results from query
        Dim oGroup            ' To enumerate through collection
        Dim lReturn           ' Function return value    

        On error resume next

        lReturn = NO_ERROR
        szGroupName = ""
        set colAccounts = Nothing
        set oGroup = Nothing

        Dbg DBG_STD, "GetGroupNameForSID: " & szSID

        ' Do the query
        if (NO_ERROR = lReturn) Then
            Set colAccounts = GetObject("winmgmts://./root/cimv2").ExecQuery _
                                       ("Select Name from Win32_Group " & _
                                        "WHERE Domain = '.' " & _ 
                                        "AND SID = '" & szSID & "'") 
            if (err.number) or (colAccounts is nothing) Then
                Error "Failed to query for group with SID " & szSID
                Error err.description & " " & err.number
                lReturn = -1
            end if
        end if


        ' Must get one and one item only back
        if (NO_ERROR = lReturn) Then
            if colAccounts.Count <> 1 then
                Error "Error: Query for group with SID " & szSID & " got " & colAccounts.Count & " hits"
                lReturn = -1
            end if
        end if
                            

        if (NO_ERROR = lReturn) Then
           For Each oGroup in colAccounts 
               szGroupName = oGroup.Name
           next
        end if

        Dbg DBG_STD, "GetGroupNameForSID: RC=" & lReturn & " GroupName=" & szGroupName

        set colAccounts = Nothing
        set oGroup = Nothing

        GetGroupNameForSID = lReturn

    End Function ' GetGroupNameForSID

    ' ********************************************************************
    ' * AddUserToGroup: Adds a user to a specified local group
    ' ********************************************************************
    Function AddUserToGroup(szDomainOfUserOrGroupToChange, szUserOrGroupToChange, szDCOMUsersGroupName)
   
        ' BUG BUG Using the simplest way. Not remotable. Could do with some work....
        ' net localgroup "groupname" "domain\user" /add
    
        Dim lReturn
        Dim szExec
        Dim oShell
        Dim oExec
        Dim szTemp
        
        lReturn = NO_ERROR
        set oShell = Nothing
        set oExec = Nothing

        Dbg DBG_STD, "AddUserToGroup: " & szDomainOfUserOrGroupToChange & "\" & szUserOrGroupToChange

        

        wscript.echo
        wscript.echo "Adding user to " & szDCOMUsersGroupName & "..."


        ' Build the command to execute
        if (NO_ERROR = lReturn) Then
            szExec = "net localgroup " & chr(34) & szDCOMUsersGroupName & chr(34) & " "& _
                     chr(34) 
            if len(szDomainOfUserOrGroupToChange) Then szExec = szExec & szDomainOfUserOrGroupToChange & "\"
            szExec = szExec & szUserOrGroupToChange & chr(34) & " " & "/add"
            Dbg DBG_STD, "Exec: " & szExec
        end if


        if (NO_ERROR = lReturn) Then
            Set oShell = CreateObject("WScript.Shell")
            Set oExec = oShell.Exec(szExec)

            Do While oExec.Status = 0
                WScript.Sleep 100
            Loop

            if (0 <> oExec.ExitCode) Then


                szTemp = oExec.StdErr.ReadAll
                if instr(szTemp,"1378") > 0 Then   ' Verified this even appears in Japanese locale so should be fairly safe.
                    wscript.echo "WARN: " & szDomainOfUserOrGroupToChange & " " & _
                                            szUserOrGroupToChange & _
                                            " is already in '" & szDCOMUsersGroupName & "'"
                    wscript.echo "INFO: No action taken here"
                else
                    Error "Failed to call " & szExec
                    Error szTemp
                    lReturn = -1
                end if
            else
                wscript.echo "INFO: " & szDomainOfUserOrGroupToChange & " " & szUserOrGroupToChange & " added to " & szDCOMUsersGroupName & " OK"
            end if
        end if

        set oShell = Nothing
        set oExec = Nothing

        AddUserToGroup = lReturn
           
    End Function 'AddUserToGroup


    ' ********************************************************************
    ' * RemoveUserFromGroup: Removes a user to a specified local group
    ' ********************************************************************
    Function RemoveUserFromGroup(szDomainOfUserOrGroupToChange, szUserOrGroupToChange, szDCOMUsersGroupName)
   
        ' BUG BUG Using the simplest way. Not remotable.
        ' net localgroup "groupname" "domain\user" /delete
        Dim lReturn
        Dim szExec
        Dim oShell
        Dim oExec
        Dim szTemp
        
        lReturn = NO_ERROR
        set oShell = Nothing
        set oExec = Nothing


        Dbg DBG_STD, "RemoveUserFromGroup: " & szDomainOfUserOrGroupToChange & "\" & szUserOrGroupToChange

        wscript.echo
        wscript.echo "Removing user from " & szDCOMUsersGroupName & "..."



        ' Build the command to execute
        if (NO_ERROR = lReturn) Then
            szExec = "net localgroup " & chr(34) & szDCOMUsersGroupName & chr(34) & " "& _
                     chr(34) 
            if len(szDomainOfUserOrGroupToChange) Then szExec = szExec & szDomainOfUserOrGroupToChange & "\" 
            szExec = szExec & szUserOrGroupToChange & chr(34) & " " & "/delete"
            Dbg DBG_STD, szExec
        end if


        if (NO_ERROR = lReturn) Then
            Set oShell = CreateObject("WScript.Shell")
            Set oExec = oShell.Exec(szExec)

            Do While oExec.Status = 0
                WScript.Sleep 100
            Loop

            if (0 <> oExec.ExitCode) Then


                szTemp = oExec.StdErr.ReadAll
                if instr(szTemp,"1377") > 0 Then ' Verified this even appears in Japanese locale so should be fairly safe.
                    wscript.echo "WARN: " & szDomainOfUserOrGroupToChange & " " & _
                                            szUserOrGroupToChange & _
                                           " is not in '" & szDCOMUsersGroupName & "'"
                    wscript.echo "INFO: No action taken here"
                else
                    Error "Failed to call " & szExec
                    Error szTemp
                    lReturn = -1
                end if
            else
                wscript.echo "INFO: " & szDomainOfUserOrGroupToChange & " " & szUserOrGroupToChange & " removed from " & szDCOMUsersGroupName & " OK"
            end if
        end if

        set oShell = Nothing
        set oExec = Nothing


        RemoveUserFromGroup = lReturn
           
    End Function ' RemoveUserFromGroup






    ' ********************************************************************
    ' * EnumerateGroupMembers: Dumps users in a group
    ' ********************************************************************
    Function EnumerateGroupMembers (szGroupName, oWMI)


        Dim oShell                     ' For getting local computer name
        Dim szComputer                 ' Local computer name
        Dim lReturn                    ' Function return value
        Dim colGroupUser               ' Collection from win32_groupuser query
        Dim oGroupUser                 ' Enumerating colGroupUser
        Dim szQuery                    ' WMI Query
        Dim oUserAccount               ' To determine if account is disbaled, locked out or expired pwd.

        Set oShell = Nothing 
        szComputer = ""
        lReturn = NO_ERROR
        set colGroupUser = Nothing
        set oGroupUser = Nothing

        On error resume next

        wscript.echo " "

        Dbg DBG_STD, "EnumerateGroupMembers: Group=" & szGroupName
        wscript.echo " "
        wscript.echo "-------------------------------------------------------------------------------"
        wscript.echo "Contents of Group " & szGroupName
        wscript.echo "-------------------------------------------------------------------------------"
        wscript.echo " "


        ' Need WScript.Shell to get the computer name environment variable
        if (NO_ERROR = lReturn) Then
            Set oShell = WScript.CreateObject("WScript.Shell") 
            if (err.number) or (oShell is nothing) Then
                Error "Failed to instantiate wscript.shell"
                Error err.description & " " & err.number
                lReturn = -1 
            end if
        end if

        ' Get the local computer name
        if (NO_ERROR = lReturn) Then
            szComputer = oShell.ExpandEnvironmentStrings("%COMPUTERNAME%")  
            if (err.number) or (0 = len(szComputer)) Then
                Error "Failed to get local computer name"
                Error err.description & " " & err.number
                lReturn = -1 
            end if
        end if


        ' BUG BUG. One of the reasons this script only runs locally. Can't use . in this query.
        ' Get the list of group members
        if (NO_ERROR = lReturn) Then
            szQuery = "SELECT * FROM Win32_GroupUser WHERE " & _ 
                      "GroupComponent = ""Win32_Group.Domain='" & szComputer & _
                      "',Name='"& szGroupName &"'"""
            set colGroupUser = oWMI.ExecQuery(szQuery)
            if (err.number) or (colGroupUser is nothing) Then
                Error "Failed to query WMI for " & szQuery
                Error err.description & " " & err.number
                lReturn = -1 
            end if
        end if

        ' Enumerate them
        if (NO_ERROR = lReturn) Then
            if colGroupUser.Count = 0 then 
                wscript.echo "There are no members in " & szGroupName
            else
                wscript.echo colGroupUser.Count & " member(s) are in " & szGroupName
                wscript.echo
            end if
            for each oGroupUser in colGroupUser
                wscript.echo "   - " & oWMI.Get(oGroupUser.PartComponent).Caption

                ' New for 0.4 Look for problematic user accounts
                if lcase(oWMI.Get(oGroupUser.PartComponent).Path_.Class) = "win32_useraccount" Then

                    'wscript.echo oWMI.Get(oGroupUser.PartComponent).GetObjectText_

                    set oUserAccount = oWMI.Get(oGroupUser.PartComponent)
                    if oUserAccount.Disabled = True then
                        wscript.echo "               ****WARN: This account is disabled"
                        glWarns = glWarns + 1
                        gszWarns = gszWarns & glWarns & ": Found a disabled user account" & vbcrlf
                    end if
                    if oUserAccount.Lockout = True then
                        wscript.echo "               ****WARN: This account is Locked out"
                        glWarns = glWarns + 1
                        gszWarns = gszWarns & glWarns & ": Found a locked out user account" & vbcrlf
                    end if
'0.5 This was wrong in 0.4
'                    if oUserAccount.PasswordExpires = True then
'                        wscript.echo "               ****WARN: This account has an expired password"
'                        glWarns = glWarns + 1
'                        gszWarns = gszWarns & glWarns & ": Found an account with an expired password" & vbcrlf
'                    end if



                end if
            next
        End if

        Set oShell = Nothing 
        set colGroupUser = Nothing
        set oGroupUser = Nothing                               
        set oUserAccount = Nothing

        EnumerateGroupMembers = lReturn
          
    End Function ' EnumerateGroupMembers

    ' ********************************************************************
    ' * ConnectNameSpace: Creates a connection to a WMI namespace
    ' ********************************************************************
    Function ConnectNameSpace(szNameSpace, szRemoteServer, ByRef oWbemServices, bSilent)

        Dim lReturn

        On error resume next

        lReturn = NO_ERROR
        Dbg DBG_STD, "ConnectNameSpace Entry: Namespace=" & szNameSpace 

        ' http://msdn.microsoft.com/en-us/library/aa393850(VS.85).aspx
        oSWbemLocator.Security_.AuthenticationLevel = wbemAuthenticationLevelDefault
        oSWbemLocator.Security_.ImpersonationLevel = wbemImpersonationLevelImpersonate


        if szRemoteServer = "" then
            set oWbemServices=oSWbemLocator.ConnectServer(".",szNameSpace)
        else
            set oWbemServices=oSWbemLocator.ConnectServer(szRemoteServer,szNameSpace)
        end if

        if (err.number) Then
            lReturn = -1
            if not(bSilent) then
                Error "Failed to connect to " & szNameSpace 
                Error "Error:     " & err.number & " " & err.description
                Error "Namespace: " & szNamespace
            end if
        else
            Dbg DBG_STD, "ConnectNameSpace Connected to " & szNamespace & " namespace "
        end if

        Dbg DBG_STD, "ConnectNameSpace Exit: Namespace=" & szNameSpace & ", RC=" & lReturn    
        ConnectNameSpace = lReturn

    end Function ' ConnectNameSpace


    ' ********************************************************************
    ' * AmILatestVersion: Version checker.
    ' ********************************************************************
    ' -1 Failure of some kind
    ' -2 Could not locate 
    '  1 No
    '  0 Yes
    Function AmILatestVersion(szURL)
   
   
       Dim oHTTP
       Dim lReturn
       Dim i              ' Iteration
       Dim aResponses     ' Array of version responses
       Dim arrTemp        ' Parsing each string we get
       Dim aLatest
       Dim aThisScript
       Dim bLatest
       bLatest = True


       on error resume next

       set oHTTP = Nothing
       lReturn = NO_ERROR

       if (NO_ERROR = lReturn) Then
           'set oHTTP = CreateObject("msxml2.xmlhttp")
           set oHTTP = CreateObject("msxml2.ServerXMLHTTP.3.0")  ' 0.7 to allow setTimeouts
           if (err.number) or (oHTTP is nothing) Then
               err.clear
               DBG DBG_EXTRA, "Failed to create msxml2.xmlhttp"
               lReturn = -1
           end if
       end if

       if (NO_ERROR = lReturn) Then
           oHTTP.setTimeouts 30*1000,30*1000,30*1000,8*1000 
           err.clear

           oHTTP.Open "GET", szURL, false

           Dim szUA

           szUA = szUA & "Mozilla/4.0+(compatible;+" & VERSION  & ";"
           if (glClientServerMode=HVREMOTE_MODE_CLIENT) Then szUA = szUA & "+CLNT;"
           if (glClientServerMode=HVREMOTE_MODE_SERVER) Then szUA = szUA & "+SVR;"
           if len(gszRemoteComputerName) Then 
               szUA = szUA & "+TARG;"
               if (glClientServerMode = HVREMOTE_MODE_CLIENT) then szUA = szUA & "Pass" & glTestsPassed & "Of7;"
           end if
           if (glServerOpAddRemoveUser=HVREMOTE_SERVEROP_ADDREMOVEUSER_ADD) Then szUA = szUA & "+Add;"
           if (glServerOpAddRemoveUser=HVREMOTE_SERVEROP_ADDREMOVEUSER_REMOVE) Then szUA = szUA & "+Remove;"
           if (gbShowMode) Then szUA = szUA & "+SHOW;"
           if (gbComputerIsWorkgroup) Then szUA = szUA & "+WG;" else szUA = szUA & "+DOM;"
           if (gbIsSCVMM) Then szUA = szUA & "+SCVMM;"
'           if (glElevated = ELEVATION_YES) Then szUA = szUA & "+Elev;" else szUA = szUA & "+NonElev;"
           if (glClientOpFirewallMMCException = HVREMOTE_CLIENTOP_FIREWALL_MMCEXCEPTION_ALLOW) Then szUA = szUA & "+MMCAdd;"
           if (glClientOpFirewallMMCException = HVREMOTE_CLIENTOP_FIREWALL_MMCEXCEPTION_DENY) Then szUA = szUA & "+MMCDeny;"
           szUA = szUA & ")"

           oHTTP.setRequestHeader "User-Agent", szUA
           if (err.number) Then
               err.clear
               DBG DBG_EXTRA, "Failed to get"
               lReturn = -1
           end if
       end if

       if (NO_ERROR = lReturn) Then
           oHTTP.Send             
           if (err.number) Then

                DBG DBG_EXTRA, "Failed to send"
               if err.number = &H80072EE2 then ' Timeout (new in 0.7)
                   DBG DBG_EXTRA, "timeout on send"
                   lReturn = -2
               else
                   lreturn = -1
               end if
               err.clear
           end if
       end if

       ' Response will be in format
       ' **START HVREMOTE VERSION** TAG Version=0.3 TAG Date=19th November 2008 
       ' TAG URL=http://code.msdn.microsoft.com/HVRemote 
       ' TAG BlogURL=http://blogs.technet.com/jhoward/something-like-this_blah.aspx **END HVREMOTE VERSION**
       ' No, not pretty, but wanted to make sure Community Server on my blog didn't start escaping characters 
       ' which would be the case if I put it in XML for example.
       if (NO_ERROR = lReturn) Then
           Dbg DBG_EXTRA, oHTTP.ResponseText
           Dim iStart, iEnd
           iStart = instr(lCase(oHTTP.ResponseText),"**start hvremote version**")
           iEnd = instr(lCase(oHTTP.ResponseText),"**end hvremote version**")

           if (iStart > 0) and (iEnd > 0) Then

               Dim szTemp
               szTemp = mid(oHTTP.ResponseText, iStart+26, iEnd-iStart-26)
               szTemp = replace(szTemp,vbcrlf,"")
               aResponses = split(szTemp,"TAG")
           else
               Dbg DBG_EXTRA, "Not a valid version response:" & oHTTP.ResponseText
               lReturn = -2  
           end if
       end if
       


       if (NO_ERROR = lReturn) Then
           for i = 0 to ubound(aResponses)
               arrTemp = split(aResponses(i),"=")
               select case trim(lcase(arrTemp(0)))
                   case "version"  gszLV_Version    = Trim(arrTemp(1))
                   case "date"     gszLV_Date       = Trim(arrTemp(1))
                   case "url"      gszLV_URL        = Trim(arrTemp(1))
                   case "blogurl"  gszLV_BlogURL    = Trim(arrTemp(1))
               end select               
           next
       end if

       ' Validate the version
       if (NO_ERROR = lReturn) and (len(gszLV_Version)) Then
           aLatest = split(gszLV_Version, ".")
           aThisScript = split(VERSION, ".")
           if ubound(aLatest) = 1 Then
               if CLng(aLatest(0)) > CLng(aThisScript(0)) Then
                   bLatest = False
                   Dbg DBG_Std, "Failed version check on major"
               else
                  if CLng(aLatest(0)) = CLng(aThisScript(0)) Then
                      if CLng(aLatest(1)) > CLng(aThisScript(1)) Then
                          bLatest = False
                      else
                          wscript.echo "INFO: Are running the latest version"
                      end if

                  end if
               end if
           end if

           if (not bLatest) Then

               wscript.echo " "
               wscript.echo "-------------------------------------------------------------------------------"
               wscript.echo "!!!!!!      There is a newer version of HVRemote available               !!!!!!"
               wscript.echo "-------------------------------------------------------------------------------"
               wscript.echo " "

               wscript.echo "Latest Version: " & gszLV_Version
               wscript.echo "Release Date:   " & gszLV_Date
               wscript.echo "Location:       " & gszLV_URL
               glWarns = glWarns + 1
               gszWarns = gszWarns & glWarns & ": There is a later version of HVRemote available" & vbcrlf
               lReturn = 1

          End if

       end if

              
       AmILatestVersion = lReturn

    End Function

    ' ********************************************************************
    ' * CheckElevation: Looks to see if you are running elevated
    ' ********************************************************************

    ' BUG BUG. Note this is a glorious hack as I could see an easy way to call 
    ' GetTokenInformation() from VBScript. But, along the way, discovered
    ' whoami /groups http://technet.microsoft.com/en-us/library/cc771299.aspx
    ' gives the Mandatory Label SID (works on all languages including Hyper-V
    ' server. S-1-16-12288 is High Mandatory Level
    Sub CheckElevation()
        Dim oShell
        Dim oExec
        Dim lCount
        Dim szExec
        Dim szTemp
        set oShell = Nothing
        set oExec = Nothing
        lCount = 0
        On error resume next
        Set oShell = CreateObject("WScript.Shell")
        if not (oShell is nothing) Then
            szExec = "whoami /groups"
            Set oExec = oShell.Exec(szExec)
            if not(oExec is nothing) Then
                Do While (oExec.Status = 0) and (lCount < 50) ' No more than 5 seconds
                    WScript.Sleep 100
                    ' Bizarre. Looks like it blocks unless we undrain stdout
                    if not oExec.StdOut.AtEndOfStream then szTemp = szTemp & oExec.StdOut.ReadAll
                    lCount = lCount + 1
                Loop
                if (1=oExec.Status) and (0=oExec.ExitCode) Then
                    if not oExec.StdOut.AtEndOfStream then szTemp = szTemp & oExec.StdOut.ReadAll                   
                    if instr(szTemp,"S-1-16-12288") Then glElevated = ELEVATION_YES
                    if instr(szTemp,"S-1-16-8192") Then glElevated = ELEVATION_NO
                end if
            end if
        End if
        set oShell = Nothing
        set oExec = Nothing
        err.clear
    End Sub ' CheckElevation


    ' ********************************************************************
    ' * IsSCVMM: Looks for VMMAgent Service present on target
    ' * A bit simplistic, but good enough.
    ' ********************************************************************
    Function IsSCVMM(oConnection)

        Dim colServices         ' Collection of services on the box
        Dim oService            ' For enumerating the services
        Dim lReturn             ' Function return value

        lReturn = NO_ERROR
        IsSCVMM = False
        set colServices = Nothing
        set oService = Nothing

        On error resume next

        if (NO_ERROR = lReturn) Then
            set colServices = oConnection.ExecQuery("select * from win32_service where name='VMMAgent'")
            if err.number Then
                Error "Failed to query services"
                Error err.description & " " & err.number
                wscript.quit
            end if
        end if

        if (NO_ERROR = lReturn) Then
            if colServices.Count = 1 then 
                IsSCVMM = True
            end if
        end if

        set colServices = Nothing
        set oService = Nothing

    End Function ' IsSCVMM

    ' ********************************************************************
    ' * IsFirewallRunning: Is the windows firewall active?
    ' ********************************************************************
    Function IsFirewallRunning(oConnection)

        Dim colServices         ' Collection of services on the box
        Dim oService            ' For enumerating the services
        Dim lReturn             ' Function return value
        Dim oFWPolicy2          ' Object referencing the current firewall policy
        Dim CurrentProfiles     ' Current firewall policies

        On error resume next

        lReturn = NO_ERROR
        IsFirewallRunning = False
        set colServices = Nothing
        set oService = Nothing
        set oFWPolicy2 = Nothing

        if (NO_ERROR = lReturn) Then
            set colServices = oConnection.ExecQuery("select * from win32_service where name='MPSSvc'")
            if err.number Then
                Error "Failed to query services"
                Error err.description & " " & err.number
                wscript.quit
            end if
        end if

        if (NO_ERROR = lReturn) Then
            if colServices.Count = 1 then 
                for each oService in colServices
                    if oService.Started = False then
                        IsFirewallRunning = False
                        wscript.echo " "
                        wscript.echo "WARN: The " & oService.Caption & " is not running."
                        wscript.echo "      Not all functionality of HVRemote will be available."
                        wscript.echo "      Use 'net start mpssvc' to start it!"
                        wscript.echo " "
                        glWarns = glWarns + 1
                        gszWarns = gszWarns & glWarns & ": Firewall is not running" & vbcrlf
                    else
                        IsFirewallRunning = True
                    end if
                next
            end if
        end if

        ' Even if the service is running, it could still be disabled.
        if (NO_ERROR = lReturn) and (IsFirewallRunning = True) Then
            Set oFWPolicy2 = CreateObject("HNetCfg.FwPolicy2")
            if (err.number) or (oFWPolicy2 is nothing) Then
                Error "Failed to create HNetCfg.FwPolicy2 object"
                Error err.description & " " & lReturn
                lReturn = -1
            end if
        end if


        ' See http://msdn.microsoft.com/en-us/library/aa366328(VS.85).aspx
        if (NO_ERROR = lReturn) and (IsFirewallRunning = True) Then


            CurrentProfiles = ofwPolicy2.CurrentProfileTypes
            if ( CurrentProfiles AND NET_FW_PROFILE2_DOMAIN )  then if ofwPolicy2.FirewallEnabled(NET_FW_PROFILE2_DOMAIN) = False then IsFirewallRunning = False
            if ( CurrentProfiles AND NET_FW_PROFILE2_PRIVATE ) then if ofwPolicy2.FirewallEnabled(NET_FW_PROFILE2_PRIVATE) = False then IsFirewallRunning = False
            if ( CurrentProfiles AND NET_FW_PROFILE2_PUBLIC )  then if ofwPolicy2.FirewallEnabled(NET_FW_PROFILE2_PUBLIC) = False then IsFirewallRunning = False
            if IsFirewallRunning = False then 
                wscript.echo " "
                wscript.echo "WARN: The Windows firewall is not active in one or more active profiles."
                wscript.echo "      Not all functionality of HVRemote will be available."
                ' 0.7: KB947709 - netsh firewall deprecated in Windows 7/R2
                if gbRunningOnWin7 then
                    wscript.echo "      Use 'netsh advfirewall set currentprofile state on' to turn it on!"
                else
                    wscript.echo "      Use 'netsh firewall set opmode enable' to turn it on!"
                end if
                wscript.echo " "
                glWarns = glWarns + 1 
                gszWarns = gszWarns & glWarns & ": Firewall is not active" & vbcrlf
           end if
 
        end if 

        set colServices = Nothing
        set oService = Nothing
        set oFWPolicy2 = Nothing

    End Function ' IsFirewallRunning


    ' ********************************************************************
    ' * IPConfig: Outputs ipconfig /all
    ' ********************************************************************
    Function IPConfig()
   
        Dim lReturn
        Dim oShell
        Dim oExec
        Dim szTemp
        Dim lCount
        
        lReturn = NO_ERROR
        set oShell = Nothing
        set oExec = Nothing
        lCount = 0

        On error resume next

        wscript.echo " "
        wscript.echo "-------------------------------------------------------------------------------"
        wscript.echo "IP Configuration"
        wscript.echo "-------------------------------------------------------------------------------"
        wscript.echo " "

        if (NO_ERROR = lReturn) Then
            Set oShell = CreateObject("WScript.Shell")
            Set oExec = oShell.Exec("ipconfig /all")

                Do While (oExec.Status = 0) and (lCount < 50) ' No more than 5 seconds
                    WScript.Sleep 100
                    ' Bizarre. Looks like it blocks unless we undrain stdout
                    if not oExec.StdOut.AtEndOfStream then szTemp = szTemp & oExec.StdOut.ReadAll
                    lCount = lCount + 1
                Loop

            if (0 <> oExec.ExitCode) Then
                Error "Failed to run ipconfig /all"
                lReturn = -1
            else
                if not oExec.StdOut.AtEndOfStream then szTemp = szTemp & oExec.StdOut.ReadAll                   
                wscript.echo szTemp
            end if
        end if

        set oShell = Nothing
        set oExec = Nothing
        IPConfig = lReturn


     
    End Function ' IPConfig




    ' ********************************************************************
    ' * CmdKey: Outputs cmdkey /list
    ' ********************************************************************
    Function CmdKey()
   
        Dim lReturn
        Dim oShell
        Dim oExec
        Dim szTemp
        
        lReturn = NO_ERROR
        set oShell = Nothing
        set oExec = Nothing

        On error resume next

        wscript.echo " "
        wscript.echo "-------------------------------------------------------------------------------"
        wscript.echo "Stored Credentials"
        wscript.echo "-------------------------------------------------------------------------------"
        wscript.echo " "

        if (NO_ERROR = lReturn) Then
            Set oShell = CreateObject("WScript.Shell")
            Set oExec = oShell.Exec("cmdkey /list")

            Do While oExec.Status = 0
                WScript.Sleep 100
            Loop
            if (0 <> oExec.ExitCode) Then

                Error "Failed to run cmdkey /list"
                lReturn = -1
            else
                wscript.echo oExec.StdOut.ReadAll
            end if
        end if

        set oShell = Nothing
        set oExec = Nothing
        CmdKey = lReturn
     
    End Function ' CmdKey

    ' ********************************************************************
    ' * TestCallsToServer: Various tests for client to server connectivity
    ' ********************************************************************
    Function TestCallsToServer()

        Dim oShell
        Dim oExec
        Dim lReturn
        Dim lCount
        Dim szTemp
        Dim oCIMv2
        Dim oVirtualization
        Dim colResult
        Dim oSink
    
        set oShell = Nothing
        set oExec = Nothing
        set oCIMv2 = Nothing
        set oVirtualization = Nothing
        set colResult = Nothing
        set oSink = Nothing
        lReturn = NO_ERROR
        lCount = 0
        szTemp = ""


        On error resume next

        wscript.echo " "
        wscript.echo "-------------------------------------------------------------------------------"
        wscript.echo "Testing connectivity to server:" & gszRemoteComputerName 
        wscript.echo "-------------------------------------------------------------------------------"
        wscript.echo " "

        ' Test 1: nslookup

        if (NO_ERROR = lReturn) Then
            szTemp = ""
            lCount = 0
            wscript.echo "1: - nslookup for DNS verification. "
            wscript.echo ""
            wscript.echo "     Note that failure is OK if you don't have a DNS infrastructure"
            wscript.echo ""
            Set oShell = CreateObject("WScript.Shell")
            Set oExec = oShell.Exec("nslookup " & gszRemoteComputerName)
            if (0 <> oExec.ExitCode) Then
                Error "Failed to run nslookup"
                lReturn = -1
            else
                wscript.echo "~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~"
                szTemp = oExec.StdOut.ReadAll
                if len(szTemp) then wscript.echo szTemp
                szTemp = oExec.StdErr.ReadAll
                if len(szTemp) then wscript.echo szTemp
                wscript.echo "~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~"
            end if
            wscript.echo ""
            if (NO_ERROR = lReturn) Then glTestsPassed = glTestsPassed + 1
        end if

        ' Test 2: ping attempt

        if (NO_ERROR = lReturn) Then
            szTemp = ""
            lCount = 0
            wscript.echo "2: - ping attempt (ping -4 -n -1 " & gszRemoteComputerName & ")"
            wscript.echo ""
            wscript.echo "     Note the ping may timeout - that is OK. However, if you get an "
            wscript.echo "     error that " & gszRemoteComputerName & " could not be found, you need to fix DNS"
            wscript.echo "     or add an entry to the hosts file. Test 3 will fail and provide more"
            wscript.echo "     guidance."
            wscript.echo ""
            wscript.echo "     This may take a second or two..."
            wscript.echo ""
            wscript.echo "~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~"
            Set oShell = CreateObject("WScript.Shell")
            Set oExec = oShell.Exec("ping -4 -n 1 " & gszRemoteComputerName)
            if (0 <> oExec.ExitCode) Then
                Error "Failed to run ping"
                lReturn = -1
            else
                szTemp = oExec.StdOut.ReadAll
                if len(szTemp) then wscript.echo szTemp
                szTemp = oExec.StdErr.ReadAll
                if len(szTemp) then wscript.echo szTemp
            end if
            wscript.echo "~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~"
            wscript.echo ""
            wscript.echo ""
            if (NO_ERROR = lReturn) Then glTestsPassed = glTestsPassed + 1
        end if

        ' Test 3: Connect to cimv2 namespace
        if (NO_ERROR = lReturn) Then
            wscript.echo "3: - Connect to root\cimv2 WMI namespace"
            lReturn = ConnectNameSpace("root\cimv2", gszRemoteComputerName, oCIMv2, False)
            if (lReturn) or (oCIMv2 is Nothing) Then
                wscript.echo "     FAIL - Was unable to connect. Diagnosis steps:"
                wscript.echo ""
                wscript.echo "     - Have you run hvremote /add:user or hvremote /add:domain\user"
                wscript.echo "       on " & gszRemoteComputerName & " to grant access?"
                wscript.echo ""
                wscript.echo "     - Are you sure the server name '" & gszRemoteComputerName & "' is correct?"
                wscript.echo ""
                wscript.echo "     - Did you use cmdkey if needed? More information higher up."
                wscript.echo ""
                wscript.echo "     - Did you restart " & gszRemoteComputerName & " after running hvremote /add for "
                wscript.echo "       the very first time? (Subsequent adds, no restart needed.)"
                wscript.echo ""
                wscript.echo "     - Is DNS operating correctly and was " & gszRemoteComputerName & " found?"
                wscript.echo "       Look at the output of tests 1 and 2 above to verify that the"
                wscript.echo "       IPv4 address matches the output of 'ipconfig /all' when run on"
                wscript.echo "       " & gszRemoteComputerName & ". If you do not have a DNS infrastructure, "
                wscript.echo "       edit \windows\system32\drivers\etc on " & gszLocalComputerName 
                wscript.echo "       to add an entry for " & gszRemoteComputerName & "."
 
                glWarns = glWarns + 1
                gszWarns = gszWarns & glWarns & ": Cannot connect to root\cimv2 on " & gszRemoteComputerName & vbcrlf
                lReturn = -1  
            else
                wscript.echo "     PASS - Connection established"
            end if
            wscript.echo ""
            if (NO_ERROR = lReturn) Then glTestsPassed = glTestsPassed + 1
        end if
        

        ' Test 4: Connect to virtualization namespace
        if (NO_ERROR = lReturn) Then
            wscript.echo "4: - Connect to root\virtualization WMI namespace"
            lReturn = ConnectNameSpace("root\virtualization", gszRemoteComputerName, oVirtualization, False)
            if (lReturn) or (oVirtualization is Nothing) Then
                wscript.echo "     FAIL - Connection attempt failed"
                wscript.echo ""
                wscript.echo "     - Have you run hvremote /add:user or hvremote /add:domain\user"
                wscript.echo "       on the server to grant access?"
                wscript.echo ""
                wscript.echo "     - Are you sure the server name has been entered correctly?"
                wscript.echo ""
                wscript.echo "     - Are you sure the server is running Hyper-V?"
                wscript.echo ""
                glWarns = glWarns + 1
                gszWarns = gszWarns & glWarns & ": Cannot connect to root\virtualization on target server" & vbcrlf
                lReturn = -1  
            else
                wscript.echo "     PASS - Connection established"
            end if
            wscript.echo ""
            if (NO_ERROR = lReturn) Then glTestsPassed = glTestsPassed + 1
        end if

        ' Test 5: Simple query to root\cimv2 namespace
        if (NO_ERROR = lReturn) Then
            wscript.echo "5: - Simple query to root\cimv2 WMI namespace"
            set colResult = oCIMv2.ExecQuery("select * from win32_operatingsystem")
            if (err.number) or (colResult is Nothing) Then
                wscript.echo "     FAIL - Simple query failed"
                glWarns = glWarns + 1
                gszWarns = gszWarns & glWarns & ": Cannot perform simple query against root\cimv2" & vbcrlf
                lReturn = -1  
            else
                wscript.echo "     PASS - Simple query succeeded"
            end if
            wscript.echo ""
            if (NO_ERROR = lReturn) Then glTestsPassed = glTestsPassed + 1
        end if
        

        ' Test 6: Simple query to root\virtualization namespace
        if (NO_ERROR = lReturn) Then
            set colResult = Nothing
            wscript.echo "6: - Simple query to root\virtualization WMI namespace"
            set colResult = oVirtualization.ExecQuery("select * from msvm_computersystem")
            if (err.number) or (colResult is Nothing) Then
                wscript.echo "     FAIL - Simple query failed"
                glWarns = glWarns + 1
                gszWarns = gszWarns & glWarns & ": Cannot perform simple query against root\virtualization" & vbcrlf
                lReturn = -1  
            else
                wscript.echo "     PASS - Simple query succeeded"
                wscript.echo "     - " & colResult.Count & " computer system(s) located"
            end if
            wscript.echo ""
            if (NO_ERROR = lReturn) Then glTestsPassed = glTestsPassed + 1
        end if


        ' Test 7: Async notifcation query. First need a sink object
        if (NO_ERROR = lReturn) Then
            wscript.echo "7: - Async notification query to root\virtualization WMI namespace"
            set oSink = Wscript.CreateObject("WbemScripting.SWbemSink","SINK_")
            if err.number or (oSink is nothing) THen
                Error "Failed to create SwbemSink object " & err.number & " " & err.description
                lReturn = -1
            end if
        end if


        if (NO_ERROR = lReturn) Then
            'http://msdn.microsoft.com/en-us/library/aa393865(VS.85).aspx
            oVirtualization.ExecNotificationQueryAsync oSink, _
               "select * from __InstanceCreationEvent within 2 where TargetInstance ISA 'MSVM_ComputerSystem'"
            if (err.number) Then
                wscript.echo "     FAIL - Notification query failed " & err.description
                wscript.echo "   "


                if (gbComputerIsWorkgroup) and not(gbAnonDCOMAllowed) then
                    wscript.echo "This machine is in a workgroup but Anonymous Logon does not have "
                    wscript.echo "DCOM access to this machine which is required."
                    wscript.echo ""
                    wscript.echo "  Run 'hvremote.wsf /mode:client /anondcom:grant' and retry."
                else
                    wscript.echo "The most likely cause of this failure is that you have not restarted the "
                    wscript.echo "server after having added a user account for the first time. Either restart "
                    wscript.echo "the server, or restart the Windows Management Instrumentation service "
                    wscript.echo "and all dependent services on the server before retrying."
                    wscript.echo ""
                    wscript.echo "Alternately, there is a DNS issue and the server cannot locate this "
                    wscript.echo "machine. You should check this by performing a ping test from the "
                    wscript.echo "server to this machine verifying that the IP address the server"
                    wscript.echo "is trying to reach matches the IPv4 address shown in the output above."
                    wscript.echo "Note that it does not matter if the ping succeeds or fails, just that"
                    wscript.echo "the IP address is correct."
                    wscript.echo " "
                    wscript.echo "  Run on " & gszRemoteComputerName & ": ping -4 " & gszLocalComputerName                     
                    wscript.echo " "
                    wscript.echo "Note that if you do not have DNS in your infrastructure, you can edit"
                    wscript.echo "the \windows\system32\drivers\etc\hosts file on the server to add an "
                    wscript.echo "entry for " & gszLocalComputerName
                    wscript.echo ""
                    wscript.echo "If you do have DNS in your infrastructure, you may want to try flushing"
                    wscript.echo "the DNS cache on the server, and re-registering against DNS on the client"
                    wscript.echo ""
                    wscript.echo " Run on " & gszRemoteComputerName & ": ipconfig /flushdns"
                    wscript.echo " Run on " & gszLocalComputerName & ": ipconfig /registerdns"
                    wscript.echo ""
                    wscript.echo "If you are connected over a VPN, see http://tinyurl.com/o4lsbw for"
                    wscript.echo "information about another likely cause."
                    if not(gbComputerIsWorkgroup) then
                        wscript.echo ""
                        wscript.echo "If the server is in an untrusted domain to this client, you need to"
                        wscript.echo "enable anonymous logon access to DCOM on this machine:"
                        wscript.echo ""
                        wscript.echo "  Run 'hvremote.wsf /mode:client /anondcom:grant' and retry."


                        wscript.echo ""
                        wscript.echo "If this machine has IPSec policy enforced on it, and the server is"
                        wscript.echo "in a workgroup, inbound connections to the client may be blocked "
                        wscript.echo "by your administrator. You may be able to temporarily work around "
                        wscript.echo "this by running net stop bfe on this machine, but you may lose access "
                        wscript.echo "to some network services while that service is stopped."
                    end if
                    

                    wscript.echo ""
                    wscript.echo ""
                    glWarns = glWarns + 1
                    gszWarns = gszWarns & glWarns & ": Cannot perform async query against root\virtualization" & vbcrlf & "   Please see resolution steps above." & vbcrlf
                    lReturn = -1  
                end if
            else
                wscript.echo "     PASS - Async notification query succeeded"
            end if
            wscript.echo ""
            if (NO_ERROR = lReturn) Then glTestsPassed = glTestsPassed + 1
        end if


        set oShell = Nothing
        set oExec = Nothing
        set oCIMv2 = Nothing
        set oVirtualization = Nothing
        set colResult = Nothing
        set oSink = Nothing

        TestCallsToServer = lReturn

    End Function

    'Sub SINK_OnObjectReady(oObject,oAsyncContext)
    '    wscript.echo "Event occurrend"
    'end sub

    'Sub SINK_OnCompleted(oObject,oAsyncContext)
    '    wscript.echo "Event call complete."
    'End sub

    ' ********************************************************************
    ' * TestCallsToClient: Various tests for server to client connectivity
    ' ********************************************************************
    Function TestCallsToClient()

        Dim oShell
        Dim oExec
        Dim lReturn
    
        set oShell = Nothing
        set oExec = Nothing
        lReturn = NO_ERROR

        On error resume next


        if (NO_ERROR = lReturn) Then
        wscript.echo " "
        wscript.echo "-------------------------------------------------------------------------------"
        wscript.echo "Testing connectivity to client: " & gszRemoteComputerName & " (2 tests in total)"
        wscript.echo "-------------------------------------------------------------------------------"
        wscript.echo " "
        wscript.echo ""
        wscript.echo "Test 1"
        wscript.echo "------"
        wscript.echo ""
        wscript.echo "    This test verifies your DNS infrastructure. For Hyper-V remote management, "
        wscript.echo "    " & gszLocalComputerName & " must be able to resolve the IP address of " & gszRemoteComputerName & "."
        wscript.echo ""
        wscript.echo "    If you do not have a DNS infrastructure, test 1 may legitimately fail."
        wscript.echo "    However, you will have to edit \windows\system32\drivers\etc\hosts on this"
        wscript.echo "    computer to add an entry for " & gszRemoteComputerName & "."
        wscript.echo ""
        wscript.echo "    If you have a DNS infrastructure and test 1 fails, this is a strong "
        wscript.echo "    indication that Hyper-V remote management will not work."
        wscript.echo ""
        wscript.echo "        a) Verify that " & gszRemoteComputerName & " is the correct client name"
        wscript.echo "        b) On " & gszLocalComputerName & ", run ipconfig /flushdns"
        wscript.echo "        c) On " & gszRemoteComputerName & ", run ipconfig /registerDNS"
        wscript.echo ""
        wscript.echo "    If you have a DNS infrastructure and test 1 succeeds, verify the IPv4"
        wscript.echo "    address returned matches the IPv4 address of " & gszRemoteComputerName & ". This can be"
        wscript.echo "    found by running ipconfig /all on " & gszRemoteComputerName & "."
        wscript.echo ""
        wscript.echo "    If you find the incorrect IP address is returned, follow steps a) to c) "
        wscript.echo "    described above, plus step d) below."
        wscript.echo ""
        wscript.echo "        d) Check the hosts file on " & gszLocalComputerName & " for incorrect entries."
        wscript.echo ""
        wscript.echo "~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~"
        end if        


        ' Test 1: nslookup

        if (NO_ERROR = lReturn) Then

            Set oShell = CreateObject("WScript.Shell")
            Set oExec = oShell.Exec("nslookup " & gszRemoteComputerName)
            if (0 <> oExec.ExitCode) Then
                Error "Failed to run nslookup"
                lReturn = -1
            else
                wscript.echo oExec.StdOut.ReadAll
                wscript.echo oExec.StdErr.ReadAll
            end if
        wscript.echo "~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~"
        end if

        ' Test 2: ping attempt

        if (NO_ERROR = lReturn) Then

        wscript.echo ""
        wscript.echo "Test 2"
        wscript.echo "------"
        wscript.echo ""
        wscript.echo "    This test attempts to ping " & gszRemoteComputerName & ". Like test 1, the aim is to"
        wscript.echo "    verify name resolution. Examine the output to ensure the IP address is"
        wscript.echo "    that of " & gszRemoteComputerName & "."
        wscript.echo ""
        wscript.echo "    If an incorrect IP address is shown, follow resolution steps a)"
        wscript.echo "    through d) listed above."
        wscript.echo ""
        wscript.echo "    A ping timeout is OK. It is likely the firewall on the client machine"
        wscript.echo "    is blocking inbound pings. No action need be taken."
        wscript.echo ""
        wscript.echo "    If the ping cannot locate " & gszRemoteComputerName & ", you may need to add an entry"
        wscript.echo "    in \windows\system32\drivers\etc (described above). If you have a DNS"
        wscript.echo "    infrastructure, follow steps a) through c)."
        wscript.echo ""
        wscript.echo "    This test may take a second or two..."
            wscript.echo ""
        wscript.echo "~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~"
            Set oShell = CreateObject("WScript.Shell")
            Set oExec = oShell.Exec("ping -4 -n 1 " & gszRemoteComputerName)
            if (0 <> oExec.ExitCode) Then
                Error "Failed to run ping"
                lReturn = -1
            else
                wscript.echo oExec.StdOut.ReadAll
                wscript.echo oExec.StdErr.ReadAll
            end if
        end if
        wscript.echo "~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~"

        set oShell = Nothing
        set oExec = Nothing

        TestCallsToClient = lReturn

    End Function



    ' ********************************************************************
    ' * GetRemoteServerInfo: Silently determine info of remote target
    ' * Used to determine what message should be displayed in the cmdkey warning
    ' * if the client is domain joined. Also used to get the build number of
    ' * the server to warn of incompatibilities
    ' ********************************************************************
    Function GetRemoteServerInfo(byref bIsTargetInDomain, byref szDomainOfTarget, byref szBuildOfTarget)

        Dim lReturn
        Dim oCIMv2
        Dim colResult
        Dim oResult
    
        set oCIMv2 = Nothing
        set colResult = Nothing
        set oResult = Nothing

        lReturn = NO_ERROR

        On error resume next

        ' Connect to cimv2 namespace
        if (NO_ERROR = lReturn) Then
            lReturn = ConnectNameSpace("root\cimv2", gszRemoteComputerName, oCIMv2, True)
            if (lReturn) or (oCIMv2 is Nothing) Then
                Dbg DBG_EXTRA, "GetRemoteServerInfo: Failed to connect namespace"
                lReturn = -1  
            end if
        end if

        ' Query win32_computersystem
        if (NO_ERROR = lReturn) Then

            set colResult = Nothing
            set colResult = oCIMV2.ExecQuery("select * from win32_computersystem")
            if (err.number) or (colResult is Nothing) Then
                Dbg DBG_EXTRA, "GetRemoteServerInfo: Failed to query win32_computersystem"
                lReturn = -1  
            end if
        end if


        if (NO_ERROR = lReturn) Then
            for each oResult in colResult
                Dbg DBG_EXTRA, "GetRemoteServerInfo: oResult" & vbcrlf & oResult.GetObjectText_
                bIsTargetInDomain = oResult.PartOfDomain
                szDomainOfTarget = lcase(oResult.Domain)
            next
        end if

        ' Query the Build - It's in the version. Below is an example from an R2 RC build.
        ' instance of Win32_OperatingSystem
        ' {
        ' 	BootDevice = "\\Device\\HarddiskVolume1";
        ' 	BuildNumber = "7100";
        ' 	BuildType = "Multiprocessor Free";
        ' 	Caption = "Microsoft Windows Server 2008 R2 Enterprise ";
        '  	CodeSet = "1252";
        ' 	CountryCode = "1";
        ' 	CreationClassName = "Win32_OperatingSystem";
        ' 	CSCreationClassName = "Win32_ComputerSystem";
        ' 	CSName = "HYPER-V";
        ' 	CurrentTimeZone = -420;
        ' 	DataExecutionPrevention_32BitApplications = TRUE;
        ' 	DataExecutionPrevention_Available = TRUE;
        ' 	DataExecutionPrevention_Drivers = TRUE;
        ' 	DataExecutionPrevention_SupportPolicy = 3;
        ' 	Debug = FALSE;
        ' 	Description = "";
        ' 	Distributed = FALSE;
        ' 	EncryptionLevel = 256;
        ' 	ForegroundApplicationBoost = 2;
        ' 	FreePhysicalMemory = "7534176";
        ' 	FreeSpaceInPagingFiles = "8320948";
        ' 	FreeVirtualMemory = "15846800";
        ' 	InstallDate = "20090503191152.000000-420";
        ' 	LastBootUpTime = "20090729164424.375200-420";
        ' 	LocalDateTime = "20090729175517.153000-420";
        ' 	Locale = "0409";
        ' 	Manufacturer = "Microsoft Corporation";
        ' 	MaxNumberOfProcesses = 4294967295;
        ' 	MaxProcessMemorySize = "8589934464";
        ' 	MUILanguages = {"en-US"};
        ' 	Name = "Microsoft Windows Server 2008 R2 Enterprise |C:\\Windows|\\Device\\Harddisk0\\Partition2";
        ' 	NumberOfLicensedUsers = 0;
        ' 	NumberOfProcesses = 37;
        ' 	NumberOfUsers = 2;
        ' 	OperatingSystemSKU = 10;
        ' 	Organization = "";
        ' 	OSArchitecture = "64-bit";
        ' 	OSLanguage = 1033;
        ' 	OSProductSuite = 274;
        ' 	OSType = 18;
        ' 	Primary = TRUE;
        ' 	ProductType = 3;
        ' 	RegisteredUser = "John Howard";
        ' 	SerialNumber = "00484-359-7000502-70048";
        ' 	ServicePackMajorVersion = 0;
        ' 	ServicePackMinorVersion = 0;
        ' 	SizeStoredInPagingFiles = "8320948";
        ' 	Status = "OK";
        ' 	SuiteMask = 274;
        ' 	SystemDevice = "\\Device\\HarddiskVolume2";
        ' 	SystemDirectory = "C:\\Windows\\system32";
        ' 	SystemDrive = "C:";
        ' 	TotalVirtualMemorySize = "16639988";
        ' 	TotalVisibleMemorySize = "8320948";
        ' 	Version = "6.1.7100";
        ' 	WindowsDirectory = "C:\\Windows";
        ' };


        if (NO_ERROR = lReturn) Then

            set colResult = Nothing
            set colResult = oCIMV2.ExecQuery("select * from win32_operatingsystem")
            if (err.number) or (colResult is Nothing) Then
                Dbg DBG_EXTRA, "GetRemoteServerInfo: Failed to query win32_operatingsystem"
                lReturn = -1  
            end if
        end if

        if (NO_ERROR = lReturn) Then
            for each oResult in colResult
                Dbg DBG_EXTRA, "GetRemoteServerInfo: oResult" & vbcrlf & oResult.GetObjectText_
                szBuildOfTarget = lcase(oResult.Version)
            next
        end if

        set oCIMv2 = Nothing
        set colResult = Nothing
        set oResult = Nothing

        GetRemoteServerInfo = lReturn

    End Function

    ' ********************************************************************
    ' * GetEnvironmentVariable: Does exactly what it says on the tin
    ' ********************************************************************
    Function GetEnvironmentVariable(szWhat, byref szValue)

        On error resume next


        Dim WshShell          ' For accessing the environment
        Dim oProcess          ' For the process environment variables
        Dim lReturn           ' Function return value

        On error resume next

        set WshShell = Nothing
        set oProcess = Nothing
        lReturn = NO_ERROR
        szValue = ""


        if (NO_ERROR = lReturn) Then
            Set WshShell = CreateObject("WScript.Shell")
            if (err.number) or (WshShell is nothing) Then
                Error "Failed to instantiate WScript.Shell"
                Error err.description & " " & err.number
                lReturn = -1
                wscript.quit
            end if
        end if

        if (NO_ERROR = lReturn) Then
            set oProcess = WshShell.Environment("PROCESS")
            if (err.number) or (oProcess is nothing) Then
                Error "Failed to obtain environment for current process"
                Error err.description & " " & err.number
                lReturn = -1
                wscript.quit
            end if
        end if


        ' Get the computername
        if (NO_ERROR = lReturn) Then
            szValue = oProcess.Item(szWhat)
            if (err.number) or (0 = len(szValue)) Then
                Error "Failed to obtain " & szWhat & " from environment"
                Error err.description & " " & err.number
                lReturn = -1
                wscript.quit
            end if
        end if

        GetEnvironmentVariable = lReturn
        set WshShell = Nothing
        set oProcess = Nothing


    End Function

    ' ********************************************************************
    ' * ConfigureClientTracingOn: Turns on tracing for the client UI
    ' ********************************************************************
    Function ConfigureClientTracingOn()

        On error resume next

        Dim lReturn           ' Function return value
        Dim szAppData         ' Environment Variable
        Dim szContents        ' Contents of the file we are writing
        Dim szFile            ' The full path to file
 
        lReturn = NO_ERROR
        szAppData = ""
        szFile = ""

        ' Need the appdata environment variable
        if (NO_ERROR = lReturn) Then
            lReturn = GetEnvironmentVariable("APPDATA", szAppData)
            if (lReturn) Then
                Error "Failed to get APPDATA"
                lReturn = -1
                wscript.quit
            end if
        end if


        ' Delete file if already exists
        if (NO_ERROR = lReturn) Then
             szFile = szAppData & "\Microsoft\Windows\Hyper-V\Client\1.0\VMClientTrace.config"
             if FileExists(szFile) Then
                 lReturn = DeleteFile(szFile)
                 if lReturn then
                     Error "Failed to delete old VMClientTrace.config file"
                     lReturn = -1
                 else
                     wscript.echo "INFO: Removed old trace file"
                 end if
              end if
        end if

        ' Write contents
        if (NO_ERROR = lReturn) Then
            szContents = "<?xml version='1.0' encoding='utf-8'?>" & vbcrlf & _
                         "<configuration>" & vbcrlf & _
                         "  <Microsoft.Virtualization.Client.TraceConfigurationOptions>" & vbcrlf & _
                         "    <setting name='TraceTagFormat' type='System.Int32'>"  & vbcrlf & _
                         "      <value>3</value>"  & vbcrlf & _
                         "    </setting>"  & vbcrlf & _
                         "    <setting name='BrowserTraceLevel' type='System.Int32'>"  & vbcrlf & _
                         "      <value>6</value>"  & vbcrlf & _
                         "    </setting>"  & vbcrlf & _
                         "    <setting name='VMConnectTraceLevel' type='System.Int32'>"  & vbcrlf & _
                         "      <value>6</value>"  & vbcrlf & _
                         "    </setting>"  & vbcrlf & _
                         "    <setting name='VHDInspectTraceLevel' type='System.Int32'>"  & vbcrlf & _
                         "      <value>6</value>"  & vbcrlf & _
                         "    </setting>"  & vbcrlf & _
                         "  </Microsoft.Virtualization.Client.TraceConfigurationOptions>"  & vbcrlf & _
                         "</configuration>"  & vbcrlf
            szContents = Replace(szContents,"'",chr(34))
            lReturn = WriteFile(szFile,szContents)
        end if


        if (NO_ERROR = lReturn) Then
            wscript.echo "INFO: UI tracing has been turned on."
            wscript.echo "INFO: Log files are written to '%temp%\VMBrowser_Trace_YYYYMMDDHHMMSS.log'."
            wscript.echo "WARN: You must restart Hyper-V manager for the change to take effect."
            glWarns = glWarns + 1
            gszWarns = gszWarns & glWarns & ": Hyper-V manager must be restarted for the change to take effect" & vbcrlf
        end if

        ConfigureClientTracingOn = lReturn

    end Function

    ' ********************************************************************
    ' * FileExists: Returns true/false
    ' ********************************************************************
    Function FileExists(szFile)

        On error resume next
        Dim lReturn
        Dim oFSO
        
        lReturn = NO_ERROR
        set oFSO = Nothing
        FileExists = False

        if (NO_ERROR = lReturn) Then
            set oFSO = CreateObject("Scripting.FileSystemObject")
            if (err.number) or (oFSO is nothing) Then
                Error "Failed to create object scripting.filesystemobject: " & err.description & " " & hex(err.number)
                lReturn = -1
            end if
        end if

        if (NO_ERROR = lReturn) Then
            FileExists = oFSO.FileExists(szFile)
        end if

        set oFSO = Nothing

    End Function

    ' ********************************************************************
    ' * DeleteFile: Removes a file from disk. Used for client tracing.
    ' ********************************************************************
    Function DeleteFile(szFile)
        On error resume next
        Dim lReturn
        Dim oFSO
        
        lReturn = NO_ERROR
        set oFSO = Nothing

        if (NO_ERROR = lReturn) Then
            set oFSO = CreateObject("Scripting.FileSystemObject")
            if (err.number) or (oFSO is nothing) Then
                Error "Failed to create object scripting.filesystemobject: " & err.description & " " & hex(err.number)
                lReturn = -1
            end if
        end if

        if (NO_ERROR = lReturn) Then
            oFSO.DeleteFile(szFile)
            if (err.number) Then
                Error "Failed to delete " & szFile & vbcrlf & err.description & " " & hex(err.number)
                lReturn = -1
            end if
        end if

        set oFSO = Nothing
        DeleteFile = lReturn

    End Function

    ' ********************************************************************
    ' * WriteFile: Writes a blob of text to a file
    ' ********************************************************************
    Function WriteFile(szFile, szContents)
        On error resume next
        Dim lReturn
        Dim oFSO
        Dim oTextStream
        
        lReturn = NO_ERROR
        set oFSO = Nothing
        set oTextStream = Nothing

        if (NO_ERROR = lReturn) Then
            set oFSO = CreateObject("Scripting.FileSystemObject")
            if (err.number) or (oFSO is nothing) Then
                Error "Failed to create object scripting.filesystemobject: " & err.description & " " & hex(err.number)
                lReturn = -1
            end if
        end if

        if (NO_ERROR = lReturn) Then
            set oTextStream = oFSO.OpenTextFile(szFile,2,True)
            if (err.number) or (oTextStream is nothing) Then
                Error "Failed to OpenTextFile " & szFile & vbcrlf & err.description & " " & hex(err.number)
                lReturn = -1
            end if
        end if

        if (NO_ERROR = lReturn) Then
            oTextStream.Write(szContents)
            if (err.number) Then
                Error "Failed to write " & szFile & vbcrlf & err.description & " " & hex(err.number)
                lReturn = -1
            end if
        end if

        if (NO_ERROR = lReturn) Then
            oTextStream.Close
            if (err.number) Then
                Error "Failed to close " & szFile & vbcrlf & err.description & " " & hex(err.number)
                lReturn = -1
            end if
        end if

        set oFSO = Nothing
        set oTextStream = Nothing
        WriteFile = lReturn

    End Function


    ' ********************************************************************
    ' * ConfigureClientTracingOff: Turns off tracing for the client UI
    ' ********************************************************************
    Function ConfigureClientTracingOff()

        On error resume next

        Dim lReturn           ' Function return value
        Dim szAppData         ' Environment Variable
        Dim szContents        ' Contents of the file we are writing
        Dim szFile            ' The full path to file
 
        lReturn = NO_ERROR
        szAppData = ""
        szFile = ""

        ' Need the appdata environment variable
        if (NO_ERROR = lReturn) Then
            lReturn = GetEnvironmentVariable("APPDATA", szAppData)
            if (lReturn) Then
                Error "Failed to get APPDATA"
                lReturn = -1
                wscript.quit
            end if
        end if


        ' Delete file if already exists
        if (NO_ERROR = lReturn) Then
             szFile = szAppData & "\Microsoft\Windows\Hyper-V\Client\1.0\VMClientTrace.config"
             if FileExists(szFile) Then
                 lReturn = DeleteFile(szFile)
                 if lReturn then
                     Error "Failed to delete old VMClientTrace.config file"
                     lReturn = -1
                 else
                     wscript.echo "INFO: UI tracing has been turned off."
                     wscript.echo "WARN: You must restart Hyper-V manager for the change to take effect."
                     glWarns = glWarns + 1
                     gszWarns = gszWarns & glWarns & ": Hyper-V manager must be restarted for the change to take effect" & vbcrlf

                  end if
              else
                     wscript.echo "WARN: UI tracing is already turned off."
                     glWarns = glWarns + 1
                     gszWarns = gszWarns & glWarns & ": No changes made to tracing setting" & vbcrlf
              end if
        end if

        ConfigureClientTracingOff = lReturn


    end Function

    ' ********************************************************************
    ' * CheckTracing: Looks to see if tracing is turned on (file exists, not the content)
    ' ********************************************************************
    Sub CheckTracing()

        On error resume next

        Dim lReturn           ' Function return value
        Dim szAppData         ' Environment Variable
        Dim szContents        ' Contents of the file we are writing
        Dim szFile            ' The full path to file
 
        lReturn = NO_ERROR
        szAppData = ""
        szFile = ""

        ' Need the appdata environment variable
        if (NO_ERROR = lReturn) Then
            lReturn = GetEnvironmentVariable("APPDATA", szAppData)
            if (lReturn) Then
                Error "Failed to get APPDATA"
                lReturn = -1
                wscript.quit
            end if
        end if

        ' Check for existance
        if (NO_ERROR = lReturn) Then
             szFile = szAppData & "\Microsoft\Windows\Hyper-V\Client\1.0\VMClientTrace.config"
             if FileExists(szFile) then
                 wscript.echo "WARN: UI tracing is turned on. Use 'hvremote /trace:off' to turn off"
                 glWarns = glWarns + 1
                 gszWarns = gszWarns & glWarns & ": UI tracing is turned on. Run 'hvremote /trace:off'" & vbcrlf
              end if
        end if

    end Sub


    ' ********************************************************************
    ' * IsQFEInstalled: Checks for a particular QFE
    ' ********************************************************************
    Function IsQFEInstalled(oConnection, szQFE)

        Dim colQFEs                    ' Collection of installed hotfixes
        Dim oQFE                       ' For enumerating the hotfixes

        On error resume next

        set colQFEs = Nothing
        set oQFE = Nothing

        set colQFEs = oConnection.ExecQuery("select * from win32_quickfixengineering")
        for each oQFE in colQFEs
           if lcase(oQFE.HotFixID) = lcase(szQFE) or lcase(oQFE.HotFixID) = "kb" & szQFE Then
               IsQFEInstalled = True
               exit for
           end if
        next

        set colQFEs = Nothing
        set oQFE = Nothing

    End Function


   ]]>

  </script>
 </job>
</package>
